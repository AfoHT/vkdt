#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 0) uniform params_t
{
  roi_t ri;
  roi_t ro;
} params;

layout(push_constant, std140) uniform push_t
{
  vec4 x;
  vec4 y;
  vec4 m;
  float black;
} push;

layout( // input f16 buffer luminance
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output f16 buffer luminance
    set = 1, binding = 1, r16f
) uniform image2D img_out;

// TODO: move to header?
// cubic hermite for four nodes
float
hermite4(float v)
{
  vec2 x = push.x.xy;
  vec2 y = push.y.xy;
  vec2 m = push.m.xy;
  // linear extension if outside [0,1]
  if(v < push.x.x)
    return push.y.x + (v - push.x.x) * push.m.x;
  if(v > push.x.w)
    return push.y.w + (v - push.x.w) * push.m.w;

  if(v > push.x.z)
  {
    x = push.x.zw;
    y = push.y.zw;
    m = push.m.zw;
  }
  else if(v > push.x.y)
  {
    x = push.x.yz;
    y = push.y.yz;
    m = push.m.yz;
  }
  float h = x.y - x.x;
  float t = (v - x.x)/h;
  float t2 = t * t;
  float t3 = t * t2;
  float h00 =  2.0 * t3 - 3.0 * t2 + 1.0;
  float h10 =  1.0 * t3 - 2.0 * t2 + t;
  float h01 = -2.0 * t3 + 3.0 * t2;
  float h11 =  1.0 * t3 - 1.0 * t2;
  return h00 * y.x + h10 * h * m.x + h01 * y.y + h11 * h * m.y;
}

// ACEScc as specified in S-2014-003
float
acescc(float v)
{
  if(v <= 0.0)
    return (log2(.00001526) + 9.72)/17.52;
  else if(v < .0000305175) // 2^-15
    return (log2(.00001526 + .5*v) + 9.72)/17.52;
  else
    return (log2(v) + 9.72)/17.52;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

  float l0 = texelFetch(img_in, ipos, 0).r;

  // xyz luma
  // vec3 w = vec3(0.299, 0.587, 0.114);
  // float l0 = dot(w, rgb);
  // float l0 = acescc(l1);

  const float black_ev = push.black;
  const float black = exp2(black_ev);
  float white = 1.0f+exp2(black_ev);
  float l1 = (log2(l0+black)-black_ev)/(log2(white)-black_ev);
  l1 = hermite4(l1);// + push.detail * (l0 - l1));
  // colour reconstruction: keep rgb saturation ratio same as before
  // rgb *= l1/l0;
  // want to see why 8-bit output sucks? try this:
  // float l1 = hermite4(ipos.x / float(push.ro.roi.x));
  // rgba.rgb = vec3(l1);
  imageStore(img_out, ipos, vec4(vec3(l1), 1));
}

