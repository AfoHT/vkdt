#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float scale;
  float shape;
} params;

layout( // input f16 buffer rgba
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output f16 buffer rgba
    set = 1, binding = 1
) uniform writeonly image2D img_out;

layout( // output f16 buffer rgba
    set = 1, binding = 2
) uniform writeonly image2D img_crv;

float
weibull_cdf(
    float x,  // input value (0, infty)
    float lm, // weibull lambda, scale parameter (0, infty)
    float k)  // weibull k, shape parameter      (0, infty)
{
  return 1.0 - exp(-pow(max(x, 1e-10)/lm, k));
}

float // derivative of cdf:
weibull_pdf(float x, float lm, float k)
{
  x = max(x, 1e-10);
  return k/lm * pow(x/lm, k-1.0) * exp(-pow(x/lm, k));
}
vec3 // vector version
weibull_cdf(vec3 x, float lm, float k)
{
  return 1.0 - exp(-pow(max(x, 1e-10)/lm, vec3(k)));
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  float lm = max(1e-10, params.scale);
  float k  = max(1e-10, params.shape);
  vec3 col0 = texelFetch(img_in, ipos, 0).rgb;
#if 0 // luminance:
  // avoid negative luma due to noise or extreme colour saturation:
  const float l0 = max(luminance_rec2020(rgb), 1e-10);
  float l1 = curve(l0);
  // colour reconstruction: keep rgb saturation ratio same as before
  vec3 col1 = col0 * l1/l0;
#else // per channel curve:
  vec3 col1 = weibull_cdf(col0, lm, k);
  col1 = adjust_colour_dng(col0, col1);
#endif

  if(all(lessThan(ipos, imageSize(img_crv))))
  {
    vec4 col_crv = vec4(0, 0, 0, 1);
    float of0 = 0;//0.1; // extend range outside [0,1]?
    float off = of0 * imageSize(img_crv).x;
    float x = ipos.x/float(imageSize(img_crv).x - off);
    float y = weibull_cdf(x, lm, k);
    float ddx = weibull_pdf(x, lm, k);
    const float w = 2.0; // stroke width
    float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
    float d = abs((1.0+of0-y) * (1.0-of0) * imageSize(img_crv).y - ipos.y);
    col_crv = max(col_crv, 0.2 * vec4(vec3(smoothstep(t, 0.0, d)), 1));
    imageStore(img_crv, ipos, col_crv);
  }

  imageStore(img_out, ipos, vec4(col1, 1));
}

