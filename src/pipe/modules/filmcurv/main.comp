#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable

#include "shared.glsl"
#include "shared/munsell.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float scale;
  float shape;
} params;

layout( // input f16 buffer rgba
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output f16 buffer rgba
    set = 1, binding = 1
) uniform writeonly image2D img_out;

layout( // output f16 buffer rgba
    set = 1, binding = 2
) uniform writeonly image2D img_crv;

float
weibull_cdf(
    float x,  // input value (0, infty)
    float lm, // weibull lambda, scale parameter (0, infty)
    float k)  // weibull k, shape parameter      (0, infty)
{
  return 1.0 - exp(-pow(max(x, 1e-10)/lm, k));
}

float // derivative of cdf:
weibull_pdf(float x, float lm, float k)
{
  x = max(x, 1e-10);
  return k/lm * pow(x/lm, k-1.0) * exp(-pow(x/lm, k));
}
vec3 // vector version
weibull_cdf(vec3 x, float lm, float k)
{
  return 1.0 - exp(-pow(max(x, 1e-10)/lm, vec3(k)));
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  float lm = max(1e-10, params.scale);
  float k  = max(1e-10, params.shape);
  vec3 col0 = texelFetch(img_in, ipos, 0).rgb;
#if 0 // luminance:
  // avoid negative luma due to noise or extreme colour saturation:
  const float l0 = max(luminance_rec2020(col0), 1e-10);
  float l1 = weibull_cdf(l0, lm, k);
  // colour reconstruction using derivative + hue constancy. looks weird:
  const mat3 xyz_to_rec2020 = mat3(
      1.7166511880, -0.6666843518, 0.0176398574, 
      -0.3556707838, 1.6164812366, -0.0427706133, 
      -0.2533662814, 0.0157685458, 0.9421031212);
  vec3 xyz = inverse(xyz_to_rec2020) * col0;
  vec2 xy = xyz.xy / dot(vec3(1),xyz);
  vec2 m = munsell_from_xy(xy);
  m.y *= 1.0 + 0.05 * (weibull_pdf(l0, lm, k) - 1.0);
  xy = munsell_to_xy(m);
  xyz = vec3(xy, 1.0-xy.x-xy.y) * dot(vec3(1),xyz) * l1/l0;
  vec3 col1 = xyz_to_rec2020 * xyz;
#else // per channel curve:
  vec3 col1 = weibull_cdf(col0, lm, k);
  col1 = adjust_colour_dng(col0, col1);
#endif

  if(all(lessThan(ipos, imageSize(img_crv))))
  {
    vec4 col_crv = vec4(0, 0, 0, 1);
    float of0 = 0;//0.1; // extend range outside [0,1]?
    float off = of0 * imageSize(img_crv).x;
    float x = ipos.x/float(imageSize(img_crv).x - off);
    float y = weibull_cdf(x, lm, k);
    float ddx = weibull_pdf(x, lm, k);
    const float w = 2.0; // stroke width
    float t = w * sqrt(1.0 + ddx*ddx); // line thinckness along const y
    float d = abs((1.0+of0-y) * (1.0-of0) * imageSize(img_crv).y - ipos.y);
    col_crv = max(col_crv, 0.2 * vec4(vec3(smoothstep(t, 0.0, d)), 1));
    imageStore(img_crv, ipos, col_crv);
  }

  imageStore(img_out, ipos, vec4(col1, 1));
}

