#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "llap.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 0) uniform params_t
{
  roi_t ri;
  roi_t ro;
  float sigma;
  float shadows;
  float highlights;
  float clarity;
} params;

layout( // input f16 buffer rgba
    set = 1, binding = 0
) uniform sampler2D img_in;

// output buffers for each curve level
layout(set = 1, binding = 1) uniform writeonly image2D img_out[];

layout(push_constant, std140) uniform push_t
{
  uint num_gamma;
} push;

float
curve(
    float x,
    float g,
    float sigma,
    float shadows,
    float highlights,
    float clarity)
{
  const float c = x-g;
  float val;
  const float ssigma = c > 0.0f ? sigma : - sigma;
  const float shadhi = c > 0.0f ? shadows : highlights;
  if (abs(c) > 2*sigma) val = g + ssigma + shadhi * (c-ssigma); // linear part
  else
  { // blend in via quadratic bezier
    const float t = clamp(c / (2.0f*ssigma), 0.0f, 1.0f);
    const float t2 = t * t;
    const float mt = 1.0f-t;
    val = g + ssigma * 2.0f*mt*t + t2*(ssigma + ssigma*shadhi);
  }
  // midtone local contrast
  val += clarity * c * exp(-c*c/(2.0f*sigma*sigma/3.0f));
  return val;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ri.roi))) return;

  float y = luminance_rec2020(texelFetch(img_in, ipos, 0).rgb);

  for(uint i=0;i<push.num_gamma;i++)
    imageStore(img_out[i], ipos,
        vec4(curve(y, gamma_from_i(i),
            params.sigma, params.shadows, params.highlights, params.clarity)));
  imageStore(img_out[push.num_gamma], ipos, vec4(y));
}

