#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "moments.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4  white;
  float split;
  float sat;
} params;


layout( // input f16 buffer rgb
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input spec coeff lut
    set = 1, binding = 1
) uniform sampler2D img_coeff;

layout( // output f16 buffer rgb
    set = 1, binding = 2
) uniform writeonly image2D img_out;

layout( // input spec coeff lut
    set = 1, binding = 3
) uniform sampler2D img_grad;

// this is sufficiently different to D65, can't use it:
double blackbody_radiation(
    double lambda,      // in [nm]
    double temperature) // in [K]
{
  const double h = 6.62606957e-34; // Planck's constant [J s]
  const double c = 299792458.0;    // speed of light [m/s]
  const double k = 1.3807e-23;     // Boltzmann's constant [J/K]
  const double lambda_m = lambda*1e-9; // lambda [m]
  const double lambda2 = lambda_m*lambda_m;
  const double lambda5 = lambda2*lambda_m*lambda2;
  const double c1 = 2. * h * c * c / lambda5;
  const double c2 = h * c / (lambda_m * temperature * k);
  // convert to spectral radiance in [W/m^2 / sr / nm]
  return 2.21566e-16 * c1 / (exp(c2)-1.0);
}

const vec3 cie_cmf[] = { // 95 entries for full list, 60 for 400..700@5 and 30 for 400..700@10
// vec3(0.000129900000,0.000003917000,0.000606100000), // 360nm
// vec3(0.000232100000,0.000006965000,0.001086000000),
// vec3(0.000414900000,0.000012390000,0.001946000000),
// vec3(0.000741600000,0.000022020000,0.003486000000),
// vec3(0.001368000000,0.000039000000,0.006450001000),
// vec3(0.002236000000,0.000064000000,0.010549990000),
// vec3(0.004243000000,0.000120000000,0.020050010000),
// vec3(0.007650000000,0.000217000000,0.036210000000),
vec3(0.014310000000,0.000396000000,0.067850010000), // 400nm
// vec3(0.023190000000,0.000640000000,0.110200000000),
vec3(0.043510000000,0.001210000000,0.207400000000),
// vec3(0.077630000000,0.002180000000,0.371300000000),
vec3(0.134380000000,0.004000000000,0.645600000000),
// vec3(0.214770000000,0.007300000000,1.039050100000),
vec3(0.283900000000,0.011600000000,1.385600000000),
// vec3(0.328500000000,0.016840000000,1.622960000000),
vec3(0.348280000000,0.023000000000,1.747060000000),
// vec3(0.348060000000,0.029800000000,1.782600000000),
vec3(0.336200000000,0.038000000000,1.772110000000),
// vec3(0.318700000000,0.048000000000,1.744100000000),
vec3(0.290800000000,0.060000000000,1.669200000000),
// vec3(0.251100000000,0.073900000000,1.528100000000),
vec3(0.195360000000,0.090980000000,1.287640000000),
// vec3(0.142100000000,0.112600000000,1.041900000000),
vec3(0.095640000000,0.139020000000,0.812950100000),
// vec3(0.057950010000,0.169300000000,0.616200000000),
vec3(0.032010000000,0.208020000000,0.465180000000),
// vec3(0.014700000000,0.258600000000,0.353300000000),
vec3(0.004900000000,0.323000000000,0.272000000000),
// vec3(0.002400000000,0.407300000000,0.212300000000),
vec3(0.009300000000,0.503000000000,0.158200000000),
// vec3(0.029100000000,0.608200000000,0.111700000000),
vec3(0.063270000000,0.710000000000,0.078249990000),
// vec3(0.109600000000,0.793200000000,0.057250010000),
vec3(0.165500000000,0.862000000000,0.042160000000),
// vec3(0.225749900000,0.914850100000,0.029840000000),
vec3(0.290400000000,0.954000000000,0.020300000000),
// vec3(0.359700000000,0.980300000000,0.013400000000),
vec3(0.433449900000,0.994950100000,0.008749999000),
// vec3(0.512050100000,1.000000000000,0.005749999000),
vec3(0.594500000000,0.995000000000,0.003900000000),
// vec3(0.678400000000,0.978600000000,0.002749999000),
vec3(0.762100000000,0.952000000000,0.002100000000),
// vec3(0.842500000000,0.915400000000,0.001800000000),
vec3(0.916300000000,0.870000000000,0.001650001000),
// vec3(0.978600000000,0.816300000000,0.001400000000),
vec3(1.026300000000,0.757000000000,0.001100000000),
// vec3(1.056700000000,0.694900000000,0.001000000000),
vec3(1.062200000000,0.631000000000,0.000800000000),
// vec3(1.045600000000,0.566800000000,0.000600000000),
vec3(1.002600000000,0.503000000000,0.000340000000),
// vec3(0.938400000000,0.441200000000,0.000240000000),
vec3(0.854449900000,0.381000000000,0.000190000000),
// vec3(0.751400000000,0.321000000000,0.000100000000),
vec3(0.642400000000,0.265000000000,0.000049999990),
// vec3(0.541900000000,0.217000000000,0.000030000000),
vec3(0.447900000000,0.175000000000,0.000020000000),
// vec3(0.360800000000,0.138200000000,0.000010000000),
vec3(0.283500000000,0.107000000000,0.000000000000),
// vec3(0.218700000000,0.081600000000,0.000000000000),
vec3(0.164900000000,0.061000000000,0.000000000000),
// vec3(0.121200000000,0.044580000000,0.000000000000),
vec3(0.087400000000,0.032000000000,0.000000000000),
// vec3(0.063600000000,0.023200000000,0.000000000000),
vec3(0.046770000000,0.017000000000,0.000000000000),
// vec3(0.032900000000,0.011920000000,0.000000000000),
vec3(0.022700000000,0.008210000000,0.000000000000),
// vec3(0.015840000000,0.005723000000,0.000000000000),
vec3(0.011359160000,0.004102000000,0.000000000000), // 700nm
// vec3(0.008110916000,0.002929000000,0.000000000000),
// vec3(0.005790346000,0.002091000000,0.000000000000),
// vec3(0.004109457000,0.001484000000,0.000000000000),
// vec3(0.002899327000,0.001047000000,0.000000000000),
// vec3(0.002049190000,0.000740000000,0.000000000000),
// vec3(0.001439971000,0.000520000000,0.000000000000),
// vec3(0.000999949300,0.000361100000,0.000000000000),
// vec3(0.000690078600,0.000249200000,0.000000000000),
// vec3(0.000476021300,0.000171900000,0.000000000000),
// vec3(0.000332301100,0.000120000000,0.000000000000),
// vec3(0.000234826100,0.000084800000,0.000000000000),
// vec3(0.000166150500,0.000060000000,0.000000000000),
// vec3(0.000117413000,0.000042400000,0.000000000000),
// vec3(0.000083075270,0.000030000000,0.000000000000),
// vec3(0.000058706520,0.000021200000,0.000000000000),
// vec3(0.000041509940,0.000014990000,0.000000000000),
// vec3(0.000029353260,0.000010600000,0.000000000000),
// vec3(0.000020673830,0.000007465700,0.000000000000),
// vec3(0.000014559770,0.000005257800,0.000000000000),
// vec3(0.000010253980,0.000003702900,0.000000000000),
// vec3(0.000007221456,0.000002607800,0.000000000000),
// vec3(0.000005085868,0.000001836600,0.000000000000),
// vec3(0.000003581652,0.000001293400,0.000000000000),
// vec3(0.000002522525,0.000000910930,0.000000000000),
// vec3(0.000001776509,0.000000641530,0.000000000000),
// vec3(0.000001251141,0.000000451810,0.000000000000), // 830nm
};


#if 1
// Journal of Computer Graphics Techniques, Simple Analytic Approximations to
// the CIE XYZ Color Matching Functions Vol. 2, No. 2, 2013 http://jcgt.org
//Inputs:  Wavelength in nanometers
float xFit_1931( float wave )
{
  float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);
  float t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);
  float t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);
  return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);
}
float yFit_1931( float wave )
{
  float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);
  float t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);
  return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);
}
float zFit_1931( float wave )
{
  float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);
  float t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);
  return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);
}
#endif

vec3 fetch_coeff(vec3 rgb, out float b)
{
  // xy chromaticity diagram
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing
  return texture(img_coeff, tc).rgb;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  if(ipos.x < params.split * imageSize(img_out).x)
  { // comparison
#if 0 // do something at all?
    vec3 cwp = vec3(params.white);//params.temp*0.49 + 0.5, 1.0, 0.5 - params.temp*0.49); // white
    // multiply saturation in rgb?
    float c = (rgb.r + rgb.g + rgb.b)/3.0;
    rgb.r = (rgb.r - c)*params.sat + c;
    rgb.g = (rgb.g - c)*params.sat + c;
    rgb.b = (rgb.b - c)*params.sat + c;
#if 0 // straight multiplication:
    // this sticks to the rec2020 boundary because it doesn't go < 0
    rgb /= cwp; 
#else // bradford adaptation:
    const mat3 rec2020_to_xyz = mat3(
      6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
      1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
      1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
    const mat3 xyz_to_rec2020 = mat3(
      1.71665119, -0.66668435,  0.01763986,
     -0.35567078,  1.61648124, -0.04277061,
     -0.25336628,  0.01576855,  0.94210312);
#if 0
    const mat3 xyz_to_bradford = mat3(
       0.8951000, -0.7502000,  0.0389000,
       0.2664000,  1.7135000, -0.0685000,
      -0.1614000,  0.0367000,  1.0296000);
    const mat3 bradford_to_xyz = mat3(
       0.9869929, 0.4323053, -0.0085287,
      -0.1470543, 0.5183603,  0.0400428,
       0.1599627, 0.0492912,  0.9684867);
    // convert white and rgb to xyz to bradford:
    cwp = xyz_to_bradford * (rec2020_to_xyz * cwp);
    rgb = xyz_to_bradford * (rec2020_to_xyz * rgb);
    rgb /= cwp;
    rgb = clamp(rgb, vec3(0.), vec3(1.));
    rgb = xyz_to_rec2020 * (bradford_to_xyz * rgb);
#else // divide in XYZ
    cwp = rec2020_to_xyz * cwp;
    rgb = rec2020_to_xyz * rgb;
    rgb /= cwp;
    rgb = xyz_to_rec2020 * rgb;
#endif
#endif
#endif
  }
  else
  { // spectral
  const mat3 xyz_to_rec2020 = mat3(
    1.71665119, -0.66668435,  0.01763986,
   -0.35567078,  1.61648124, -0.04277061,
   -0.25336628,  0.01576855,  0.94210312);
#if 0 // moments
  float b;
  vec3 cwp   = fetch_coeff(vec3(params.white));//vec3(params.temp*0.49 + 0.5, 1.0, 0.5 - params.temp*0.49), b);
  vec3 coeff = fetch_coeff(rgb, b);

  // apply saturation by blurring the spectrum. in fourier space this means
  // we multiply the coefficients by the fourier transform of the kernel.
  // this is a poisson kernel (right..?):
  vec2 exp_momc[3], eval_polyc[3];
  {
    float r = params.sat; // 1.0 + 5.0 * params.sat; // radius
    // this is not poisson, coeff.y also has r^2 because then it looks good. (??)
    vec3 cf2 = vec3(coeff.x, coeff.y * r*r, coeff.z * r*r);
    prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
    // TODO: does not work yet!
    if(!valid(exp_momc))
    {
      // just mark as broken:
      // prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, vec3(0.1, 0, 0));//coeff);
#if 1
      // iterate back to last good r
      float lo = 0.0;
      float hi = r;
      for(int k=0;k<10;k++)
      {
        float r = (lo+hi)*0.5;
        vec3 cf2 = vec3(coeff.x, coeff.y * r*r, coeff.z * r*r);
        prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
        if(!valid(exp_momc))
          hi = r;
        else
          lo = r;
      }
      r = lo;
      vec3 cf2 = vec3(coeff.x, coeff.y * r*r, coeff.z * r*r);
      prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
#endif
    }
  }

  const int num_l = 30;
  vec3 xyz = vec3(0);
  const vec3 norm = vec3(num_l); //* vec3(0.354678, 0.355529, 0.34371);
  vec2 exp_momw[3], eval_polyw[3];
  prepareReflectanceSpectrumReal3(exp_momw, eval_polyw, cwp);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    const float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    const float phase = lambda_to_phase(lambda);
    const float val = evaluateReflectanceSpectrum3(phase, exp_momc, eval_polyc);
    const float wht = evaluateReflectanceSpectrum3(phase, exp_momw, eval_polyw);

    // compute colour again, in xyz:
    const int bin = l;
    xyz += val * wht * cie_cmf[bin];
      // vec3(xFit_1931(lambda), yFit_1931(lambda), zFit_1931(lambda));
  }
  xyz /= norm;
  float b2 = dot(vec3(1),xyz);
  xyz *= b/b2;
  rgb = xyz_to_rec2020*xyz;
  }
#endif

#if 1 // sigmoids
  float b;
  vec3 cwp   = fetch_coeff(vec3(params.white), b);//params.temp*0.49 + 0.5, 1.0, 0.5 - params.temp*0.49), b);
  vec3 coeff = fetch_coeff(rgb, b);

  // saturation in various ways. none of which work, making me sad.
#if 0 // convert to lwd: dom lambda, width, slope
  // convert
  float c0   = coeff.x;
  float ldom = coeff.y/(-2.0*coeff.x);
  float y    = coeff.z - coeff.y*coeff.y/(4.0 * coeff.x);

  float y0 = c0 > 0.0 ? 1.0 : -2.0;
  float c = pow(y0*y0+1, -3./2.);

  float w = 2.0 * sqrt((y0 - y)/c0);
  float d = sign(c0) * sqrt(c0*(y0-y)) * c;

  // saturate
  w *= 1./params.sat;
  d *= exp(5*params.sat)/exp(5);

  // back
  // y  = y0 - 0.5 * w * abs(d) / c;
  y  = y0 - 0.5 * w * (d) / c;
  c0 = 2.0*d/(w * c);

  coeff.x = c0;
  coeff.y = -2.0 * c0 * ldom;
  coeff.z = c0 * ldom*ldom + y;
#endif

#if 1 // walk gradients
  {
  int it = int(abs(40*(params.sat-1.0)));
  float dir = (params.sat > 1.0)^^(coeff.x > 0) ? -1.0 : 1.0;
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  float b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing
  for(int i=0;i<it;i++)
  {
    vec3 grad = texture(img_grad, tc).rgb;
    tc += .01 * dir * vec2(grad.x, -grad.y);
  }
  coeff = texture(img_coeff, tc).rgb;
  }
#endif

  const int num_l = 30;
  vec3 xyz = vec3(0);
  const vec3 norm = vec3(num_l);// * vec3(0.354678, 0.355529, 0.34371);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    float x = (coeff.x * lambda + coeff.y) * lambda + coeff.z;
    float y = 1. / sqrt(x * x + 1.);
    float val = 0.5 * x * y +  0.5;
    float xw  = (cwp.x * lambda + cwp.y) * lambda + cwp.z;
    float yw  = 1. / sqrt(xw * xw + 1.);
    float wht = 0.5 * xw * yw +  0.5;

    // compute colour again, in xyz:
    // const int bin = l;
    xyz += val * wht *
      cie_cmf[l];
      // vec3( xFit_1931(lambda), yFit_1931(lambda), zFit_1931(lambda));
  }
  xyz /= norm;
  float b2 = dot(vec3(1),xyz);
  xyz *= b/b2;
  rgb = xyz_to_rec2020*xyz;
  } // end if split
#endif

  imageStore(img_out, ipos, vec4(rgb, 1));
}

