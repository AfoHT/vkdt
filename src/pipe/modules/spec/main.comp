#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "moments.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  vec4  white;
  float split;
  float sat;
} params;


layout( // input f16 buffer rgb
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input spec coeff lut
    set = 1, binding = 1
) uniform sampler2D img_coeff;

layout( // output f16 buffer rgb
    set = 1, binding = 2
) uniform writeonly image2D img_out;

layout( // input spec coeff lut
    set = 1, binding = 3
) uniform sampler2D img_grad;

// this is sufficiently different to D65, can't use it:
double blackbody_radiation(
    double lambda,      // in [nm]
    double temperature) // in [K]
{
  const double h = 6.62606957e-34; // Planck's constant [J s]
  const double c = 299792458.0;    // speed of light [m/s]
  const double k = 1.3807e-23;     // Boltzmann's constant [J/K]
  const double lambda_m = lambda*1e-9; // lambda [m]
  const double lambda2 = lambda_m*lambda_m;
  const double lambda5 = lambda2*lambda_m*lambda2;
  const double c1 = 2. * h * c * c / lambda5;
  const double c2 = h * c / (lambda_m * temperature * k);
  // convert to spectral radiance in [W/m^2 / sr / nm]
  return 2.21566e-16 * c1 / (exp(c2)-1.0);
}

// these are dumped from the lut matching utility and contain
// xyz cmf * xyz to rec2020 matrix * illuminant D65
const vec3 rgb_cmf[] = { // 30 entries, centered in 10nm bins:
// these contain no illuminant, we'll multiply ours
vec3(0.0116605, -0.0126882, 0.104201), // 405 nm
vec3(0.0384134, -0.0423759, 0.351079), // 415 nm
vec3(0.102829, -0.114999, 0.982369), // 425 nm
vec3(0.146727, -0.166193, 1.53407), // 435 nm
vec3(0.135248, -0.155766, 1.68426), // 445 nm
vec3(0.0881284, -0.107379, 1.64669), // 455 nm
vec3(0.017598, -0.0238506, 1.4409), // 465 nm
vec3(-0.0600947, 0.103709, 0.979268), // 475 nm
vec3(-0.116859, 0.244752, 0.574305), // 485 nm
vec3(-0.156256, 0.413793, 0.322044), // 495 nm
vec3(-0.194534, 0.66014, 0.18263), // 505 nm
vec3(-0.194665, 0.965505, 0.0797332), // 515 nm
vec3(-0.108478, 1.21003, 0.0219431), // 525 nm
vec3(0.0545879, 1.3288, -0.00703415), // 535 nm
vec3(0.26542, 1.34504, -0.0229588), // 545 nm
vec3(0.521884, 1.2752, -0.028321), // 555 nm
vec3(0.81582, 1.12965, -0.0272977), // 565 nm
vec3(1.12024, 0.918074, -0.0225949), // 575 nm
vec3(1.38923, 0.667138, -0.0163323), // 585 nm
vec3(1.56658, 0.418823, -0.0101392), // 595 nm
vec3(1.59318, 0.219146, -0.00523289), // 605 nm
vec3(1.45392, 0.0875787, -0.00209105), // 615 nm
vec3(1.1757, 0.0179454, -0.000380568), // 625 nm
vec3(0.853065, -0.0104993, 0.000306079), // 635 nm
vec3(0.570212, -0.0171418, 0.000462983), // 645 nm
vec3(0.346409, -0.013899, 0.000367755), // 655 nm
vec3(0.192202, -0.00873941, 0.000231237), // 665 nm
vec3(0.100927, -0.00489876, 0.000129617), // 675 nm
vec3(0.0522382, -0.00266546, 7.05256e-05), // 685 nm
vec3(0.0251563, -0.00130916, 3.46391e-05), // 695 nm
// these contain illuminant D65
// vec3(9.61375e-05, -0.00010461, 0.000859108), // 405 nm
// vec3(0.000336113, -0.000370785, 0.0030719), // 415 nm
// vec3(0.000876365, -0.00098009, 0.00837232), // 425 nm
// vec3(0.00132987, -0.0015063, 0.0139042), // 435 nm
// vec3(0.0014199, -0.00163531, 0.0176821), // 445 nm
// vec3(0.000979208, -0.00119311, 0.0182966), // 455 nm
// vec3(0.000193746, -0.000262583, 0.0158636), // 465 nm
// vec3(-0.000656245, 0.00113252, 0.0106938), // 475 nm
// vec3(-0.00124267, 0.00260267, 0.0061071), // 485 nm
// vec3(-0.00161303, 0.00427159, 0.00332447), // 495 nm
// vec3(-0.0019989, 0.00678316, 0.00187659), // 505 nm
// vec3(-0.00195821, 0.00971237, 0.000802065), // 515 nm
// vec3(-0.00109064, 0.0121656, 0.000220615), // 525 nm
// vec3(0.000547834, 0.0133356, -7.05933e-05), // 535 nm
// vec3(0.00261794, 0.0132667, -0.000226451), // 545 nm
// vec3(0.00503878, 0.012312, -0.000273439), // 555 nm
// vec3(0.00757904, 0.0104946, -0.000253598), // 565 nm
// vec3(0.0101839, 0.00834601, -0.000205405), // 575 nm
// vec3(0.0121264, 0.00582337, -0.000142563), // 585 nm
// vec3(0.0132459, 0.00354127, -8.57295e-05), // 595 nm
// vec3(0.0135397, 0.00186241, -4.44717e-05), // 605 nm
// vec3(0.0121974, 0.000734727, -1.75425e-05), // 615 nm
// vec3(0.00951223, 0.000145192, -3.07907e-06), // 625 nm
// vec3(0.00674048, -8.29604e-05, 2.41848e-06), // 635 nm
// vec3(0.00441751, -0.0001328, 3.58679e-06), // 645 nm
// vec3(0.00262656, -0.000105386, 2.78841e-06), // 655 nm
// vec3(0.0014778, -6.71953e-05, 1.77793e-06), // 665 nm
// vec3(0.000766789, -3.7218e-05, 9.84754e-07), // 675 nm
// vec3(0.000365839, -1.8667e-05, 4.9391e-07), // 685 nm
// vec3(0.000168231, -8.75491e-06, 2.31647e-07), // 695 nm
};

#if 0
const vec3 cie_cmf[] = { // 95 entries for full list, 60 for 400..700@5 and 30 for 400..700@10
// vec3(0.000129900000,0.000003917000,0.000606100000), // 360nm
// vec3(0.000232100000,0.000006965000,0.001086000000),
// vec3(0.000414900000,0.000012390000,0.001946000000),
// vec3(0.000741600000,0.000022020000,0.003486000000),
// vec3(0.001368000000,0.000039000000,0.006450001000),
// vec3(0.002236000000,0.000064000000,0.010549990000),
// vec3(0.004243000000,0.000120000000,0.020050010000),
// vec3(0.007650000000,0.000217000000,0.036210000000),
vec3(0.014310000000,0.000396000000,0.067850010000), // 400nm
// vec3(0.023190000000,0.000640000000,0.110200000000),
vec3(0.043510000000,0.001210000000,0.207400000000),
// vec3(0.077630000000,0.002180000000,0.371300000000),
vec3(0.134380000000,0.004000000000,0.645600000000),
// vec3(0.214770000000,0.007300000000,1.039050100000),
vec3(0.283900000000,0.011600000000,1.385600000000),
// vec3(0.328500000000,0.016840000000,1.622960000000),
vec3(0.348280000000,0.023000000000,1.747060000000),
// vec3(0.348060000000,0.029800000000,1.782600000000),
vec3(0.336200000000,0.038000000000,1.772110000000),
// vec3(0.318700000000,0.048000000000,1.744100000000),
vec3(0.290800000000,0.060000000000,1.669200000000),
// vec3(0.251100000000,0.073900000000,1.528100000000),
vec3(0.195360000000,0.090980000000,1.287640000000),
// vec3(0.142100000000,0.112600000000,1.041900000000),
vec3(0.095640000000,0.139020000000,0.812950100000),
// vec3(0.057950010000,0.169300000000,0.616200000000),
vec3(0.032010000000,0.208020000000,0.465180000000),
// vec3(0.014700000000,0.258600000000,0.353300000000),
vec3(0.004900000000,0.323000000000,0.272000000000),
// vec3(0.002400000000,0.407300000000,0.212300000000),
vec3(0.009300000000,0.503000000000,0.158200000000),
// vec3(0.029100000000,0.608200000000,0.111700000000),
vec3(0.063270000000,0.710000000000,0.078249990000),
// vec3(0.109600000000,0.793200000000,0.057250010000),
vec3(0.165500000000,0.862000000000,0.042160000000),
// vec3(0.225749900000,0.914850100000,0.029840000000),
vec3(0.290400000000,0.954000000000,0.020300000000),
// vec3(0.359700000000,0.980300000000,0.013400000000),
vec3(0.433449900000,0.994950100000,0.008749999000),
// vec3(0.512050100000,1.000000000000,0.005749999000),
vec3(0.594500000000,0.995000000000,0.003900000000),
// vec3(0.678400000000,0.978600000000,0.002749999000),
vec3(0.762100000000,0.952000000000,0.002100000000),
// vec3(0.842500000000,0.915400000000,0.001800000000),
vec3(0.916300000000,0.870000000000,0.001650001000),
// vec3(0.978600000000,0.816300000000,0.001400000000),
vec3(1.026300000000,0.757000000000,0.001100000000),
// vec3(1.056700000000,0.694900000000,0.001000000000),
vec3(1.062200000000,0.631000000000,0.000800000000),
// vec3(1.045600000000,0.566800000000,0.000600000000),
vec3(1.002600000000,0.503000000000,0.000340000000),
// vec3(0.938400000000,0.441200000000,0.000240000000),
vec3(0.854449900000,0.381000000000,0.000190000000),
// vec3(0.751400000000,0.321000000000,0.000100000000),
vec3(0.642400000000,0.265000000000,0.000049999990),
// vec3(0.541900000000,0.217000000000,0.000030000000),
vec3(0.447900000000,0.175000000000,0.000020000000),
// vec3(0.360800000000,0.138200000000,0.000010000000),
vec3(0.283500000000,0.107000000000,0.000000000000),
// vec3(0.218700000000,0.081600000000,0.000000000000),
vec3(0.164900000000,0.061000000000,0.000000000000),
// vec3(0.121200000000,0.044580000000,0.000000000000),
vec3(0.087400000000,0.032000000000,0.000000000000),
// vec3(0.063600000000,0.023200000000,0.000000000000),
vec3(0.046770000000,0.017000000000,0.000000000000),
// vec3(0.032900000000,0.011920000000,0.000000000000),
vec3(0.022700000000,0.008210000000,0.000000000000),
// vec3(0.015840000000,0.005723000000,0.000000000000),
vec3(0.011359160000,0.004102000000,0.000000000000), // 700nm
// vec3(0.008110916000,0.002929000000,0.000000000000),
// vec3(0.005790346000,0.002091000000,0.000000000000),
// vec3(0.004109457000,0.001484000000,0.000000000000),
// vec3(0.002899327000,0.001047000000,0.000000000000),
// vec3(0.002049190000,0.000740000000,0.000000000000),
// vec3(0.001439971000,0.000520000000,0.000000000000),
// vec3(0.000999949300,0.000361100000,0.000000000000),
// vec3(0.000690078600,0.000249200000,0.000000000000),
// vec3(0.000476021300,0.000171900000,0.000000000000),
// vec3(0.000332301100,0.000120000000,0.000000000000),
// vec3(0.000234826100,0.000084800000,0.000000000000),
// vec3(0.000166150500,0.000060000000,0.000000000000),
// vec3(0.000117413000,0.000042400000,0.000000000000),
// vec3(0.000083075270,0.000030000000,0.000000000000),
// vec3(0.000058706520,0.000021200000,0.000000000000),
// vec3(0.000041509940,0.000014990000,0.000000000000),
// vec3(0.000029353260,0.000010600000,0.000000000000),
// vec3(0.000020673830,0.000007465700,0.000000000000),
// vec3(0.000014559770,0.000005257800,0.000000000000),
// vec3(0.000010253980,0.000003702900,0.000000000000),
// vec3(0.000007221456,0.000002607800,0.000000000000),
// vec3(0.000005085868,0.000001836600,0.000000000000),
// vec3(0.000003581652,0.000001293400,0.000000000000),
// vec3(0.000002522525,0.000000910930,0.000000000000),
// vec3(0.000001776509,0.000000641530,0.000000000000),
// vec3(0.000001251141,0.000000451810,0.000000000000), // 830nm
};
#endif


#if 0
// Journal of Computer Graphics Techniques, Simple Analytic Approximations to
// the CIE XYZ Color Matching Functions Vol. 2, No. 2, 2013 http://jcgt.org
//Inputs:  Wavelength in nanometers
float xFit_1931( float wave )
{
  float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);
  float t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);
  float t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);
  return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);
}
float yFit_1931( float wave )
{
  float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);
  float t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);
  return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);
}
float zFit_1931( float wave )
{
  float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);
  float t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);
  return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);
}
#endif

vec3 fetch_coeff(vec3 rgb, out float Y)
{
  // xy chromaticity diagram
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  Y = xyz.y;
  float b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing

  // bilinear interpolation, fails at blue-white-red ridge
#if 0
  return texture(img_coeff, tc).rgb;
#else
  vec2 tci = tc * textureSize(img_coeff, 0);
  vec2 uv = fract(tci);
  vec3 c0 = texelFetch(img_coeff, ivec2(tci), 0).rgb;
  vec3 c1 = texelFetch(img_coeff, ivec2(tci)+ivec2(0,1), 0).rgb;
  vec3 c2 = texelFetch(img_coeff, ivec2(tci)+ivec2(1,0), 0).rgb;
  vec3 c3 = texelFetch(img_coeff, ivec2(tci)+ivec2(1,1), 0).rgb;
  int nshaped = 0;
  vec2 w = vec2(0.0);
  vec3 r0 = vec3(0.0);
  vec3 r1 = vec3(0.0);
  if(c0.x < 0) { w.x += (1.0-uv.x)*(1.0-uv.y); r0 += (1.0-uv.x)*(1.0-uv.y)*c0; nshaped++;}
  else { w.y += (1.0-uv.x)*(1.0-uv.y); r1 += (1.0-uv.x)*(1.0-uv.y)*c0; }
  if(c1.x < 0) { w.x += uv.x*(1.0-uv.y); r0 += uv.x*(1.0-uv.y)*c1; nshaped++;}
  else w.y += uv.x*(1.0-uv.y); r1 += uv.x*(1.0-uv.y)*c1;
  if(c2.x < 0) { w.x += (1.0-uv.x)*uv.y; r0 += (1.0-uv.x)*uv.y*c2; nshaped++;}
  else w.y += (1.0-uv.x)*uv.y; r1 += (1.0-uv.x)*uv.y*c2;
  if(c3.x < 0) { w.x += uv.x*uv.y; r0 += uv.x*uv.y*c3; nshaped++;}
  else { w.y += uv.x*uv.y; r1 += uv.x*uv.y*c3;}
  if(nshaped >= 2) 
    return r0 / w.x;
  return r1 / w.y;
#endif
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  if(ipos.x < params.split * imageSize(img_out).x)
  { // comparison
#if 1 // do something at all?
    vec3 cwp = vec3(params.white);//params.temp*0.49 + 0.5, 1.0, 0.5 - params.temp*0.49); // white
    float Y = dot(vec3(2.62700212e-01, 6.77998072e-01, 5.93017165e-02), rgb);
    // multiply saturation in rgb?
    float c = (rgb.r + rgb.g + rgb.b)/3.0;
    rgb.r = (rgb.r - c)*params.sat + c;
    rgb.g = (rgb.g - c)*params.sat + c;
    rgb.b = (rgb.b - c)*params.sat + c;
#if 1 // straight multiplication:
    // this sticks to the rec2020 boundary because it doesn't go < 0
    rgb *= cwp; 
#else // bradford adaptation:
    const mat3 rec2020_to_xyz = mat3(
      6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
      1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
      1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
    const mat3 xyz_to_rec2020 = mat3(
      1.71665119, -0.66668435,  0.01763986,
     -0.35567078,  1.61648124, -0.04277061,
     -0.25336628,  0.01576855,  0.94210312);
#if 0
    const mat3 xyz_to_bradford = mat3(
       0.8951000, -0.7502000,  0.0389000,
       0.2664000,  1.7135000, -0.0685000,
      -0.1614000,  0.0367000,  1.0296000);
    const mat3 bradford_to_xyz = mat3(
       0.9869929, 0.4323053, -0.0085287,
      -0.1470543, 0.5183603,  0.0400428,
       0.1599627, 0.0492912,  0.9684867);
    // convert white and rgb to xyz to bradford:
    cwp = xyz_to_bradford * (rec2020_to_xyz * cwp);
    rgb = xyz_to_bradford * (rec2020_to_xyz * rgb);
    rgb *= cwp;
    rgb = clamp(rgb, vec3(0.), vec3(1.));
    rgb = xyz_to_rec2020 * (bradford_to_xyz * rgb);
#else // divide in XYZ
    cwp = rec2020_to_xyz * cwp;
    rgb = rec2020_to_xyz * rgb;
    rgb *= cwp;
    rgb = xyz_to_rec2020 * rgb;
#endif
#endif
#endif
    float Y2 = dot(vec3(2.62700212e-01, 6.77998072e-01, 5.93017165e-02), rgb);
    rgb *= Y/Y2;
  }
  else
  { // spectral
  const mat3 xyz_to_rec2020 = mat3(
    1.71665119, -0.66668435,  0.01763986,
   -0.35567078,  1.61648124, -0.04277061,
   -0.25336628,  0.01576855,  0.94210312);

#if 1 // sigmoids
  float Y;
  vec3 cwp   = fetch_coeff(vec3(params.white), Y);//params.temp*0.49 + 0.5, 1.0, 0.5 - params.temp*0.49), b);
  vec3 coeff = fetch_coeff(rgb, Y);

  // saturation in various ways. none of which work, making me sad.
  // TODO: desaturation goes to illum E, should be D65!
#if 1 // convert to lwd: dom lambda, width, slope
  // convert
  float c0   = coeff.x;
  float ldom = coeff.y/(-2.0*coeff.x);
  float y    = coeff.z - coeff.y*coeff.y/(4.0 * coeff.x);

  const float y0 = c0 > 0.0 ? 1.0 : -2.0;
  const float c = pow(y0*y0+1, -3./2.);

  float w = 2.0 * sqrt((y0 - y)/c0);
  float d = sign(c0) * sqrt(c0*(y0-y)) * c;

  // saturate

  // simple heuristic, looks wonky:
  // w *= 1./params.sat;
  // d *= exp(5*params.sat)/exp(5);

  // width looks linear after some grace period
  // d looks to progress as
  // .5 + .5*log(x*.8)/sqrt(log(x*.8)**2 + .9)

  // fit to data (does not actually depend on input slope d)
  w /= params.sat * params.sat; // spectral width is reciprocal to saturation
#if 1
  // blend params of reciprocal fits:
  const vec4 fit_n  = vec4(0.0,   0.15,  20.0, 1.00); // n-shaped (spectral)
  const vec4 fit_u0 = vec4(0.0,   0.80, 310.0, 1.00); // u-shaped extremes
  const vec4 fit_u1 = vec4(0.003, 8.00, 210.0, 1.65); // u-shaped near ldom
  const vec4 fit = mix(
      fit_n,
      mix(fit_u1, fit_u0, 0),// XXX fit_u0 doesn't look good and the weight neither: pow(0.1*abs(ldom - 500.0)/200.0, 4)),
      // XXX TODO use d? d < 0 should be fit_n, d > 0 the others
      d < 0.0 ? 0.0 : 1.0);
  d = fit.x + fit.y / pow(w - fit.z, fit.w);
  d = sign(c0) * d;
#endif

  // back
  y  = y0 - 0.5 * w * (d) / c;
  c0 = 2.0*d/(w * c);

  coeff.x = c0;
  coeff.y = -2.0 * c0 * ldom;
  coeff.z = c0 * ldom*ldom + y;
#endif

#if 0 // walk gradients
  {
  int it = int(abs(40*(params.sat-1.0)));
  float dir = (params.sat > 1.0)^^(coeff.x > 0) ? -1.0 : 1.0;
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  float b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing
  for(int i=0;i<it;i++)
  {
    vec3 grad = texture(img_grad, tc).rgb;
    tc += .01 * dir * vec2(grad.x, -grad.y);
  }
  coeff = texture(img_coeff, tc).rgb;
  }
#endif

  // TODO: need to multiply 1 1 1 -> spec (D65)
  const int num_l = 30;
  rgb = vec3(0);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    const float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    float x = (coeff.x * lambda + coeff.y) * lambda + coeff.z;
    float y = 1. / sqrt(x * x + 1.);
    float val = 0.5 * x * y +  0.5;
    // TODO: how to upsample white such that 1 1 1 is illum E?
    float xw  = (cwp.x * lambda + cwp.y) * lambda + cwp.z;
    float yw  = 1. / sqrt(xw * xw + 1.);
    float wht = 0.5 * xw * yw +  0.5;

    rgb += val * wht * rgb_cmf[l];
  }
  // keep perceived brightness Y the same, evaluate new Y by row in rec2020_to_xyz
  float Y2 = dot(vec3(2.62700212e-01, 6.77998072e-01, 5.93017165e-02), rgb);
  rgb *= Y/Y2;
  } // end if split
#endif

  imageStore(img_out, ipos, vec4(rgb, 1));
}





//====================================================================
#if 0 // moments
  float b;
  vec3 cwp   = fetch_coeff(vec3(params.white));//vec3(params.temp*0.49 + 0.5, 1.0, 0.5 - params.temp*0.49), b);
  vec3 coeff = fetch_coeff(rgb, b);

  // apply saturation by blurring the spectrum. in fourier space this means
  // we multiply the coefficients by the fourier transform of the kernel.
  // this is a poisson kernel (right..?):
  vec2 exp_momc[3], eval_polyc[3];
  {
    float r = params.sat; // 1.0 + 5.0 * params.sat; // radius
    // this is not poisson, coeff.y also has r^2 because then it looks good. (??)
    vec3 cf2 = vec3(coeff.x, coeff.y * r*r, coeff.z * r*r);
    prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
    // TODO: does not work yet!
    if(!valid(exp_momc))
    {
      // just mark as broken:
      // prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, vec3(0.1, 0, 0));//coeff);
#if 1
      // iterate back to last good r
      float lo = 0.0;
      float hi = r;
      for(int k=0;k<10;k++)
      {
        float r = (lo+hi)*0.5;
        vec3 cf2 = vec3(coeff.x, coeff.y * r*r, coeff.z * r*r);
        prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
        if(!valid(exp_momc))
          hi = r;
        else
          lo = r;
      }
      r = lo;
      vec3 cf2 = vec3(coeff.x, coeff.y * r*r, coeff.z * r*r);
      prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
#endif
    }
  }

  const int num_l = 30;
  vec3 xyz = vec3(0);
  const vec3 norm = vec3(num_l); //* vec3(0.354678, 0.355529, 0.34371);
  vec2 exp_momw[3], eval_polyw[3];
  prepareReflectanceSpectrumReal3(exp_momw, eval_polyw, cwp);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    const float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    const float phase = lambda_to_phase(lambda);
    const float val = evaluateReflectanceSpectrum3(phase, exp_momc, eval_polyc);
    const float wht = evaluateReflectanceSpectrum3(phase, exp_momw, eval_polyw);

    // compute colour again, in xyz:
    const int bin = l;
    xyz += val * wht * cie_cmf[bin];
      // vec3(xFit_1931(lambda), yFit_1931(lambda), zFit_1931(lambda));
  }
  xyz /= norm;
  float b2 = dot(vec3(1),xyz);
  xyz *= b/b2;
  rgb = xyz_to_rec2020*xyz;
  }
#endif
