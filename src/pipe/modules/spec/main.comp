#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "moments.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float split;
  float temp;
  float sat;
} params;


layout( // input f16 buffer rgb
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input spec coeff lut
    set = 1, binding = 1
) uniform sampler2D img_coeff;

layout( // output f16 buffer rgb
    set = 1, binding = 2
) uniform writeonly image2D img_out;

// this is sufficiently different to D65, can't use it:
double blackbody_radiation(
    double lambda,      // in [nm]
    double temperature) // in [K]
{
  const double h = 6.62606957e-34; // Planck's constant [J s]
  const double c = 299792458.0;    // speed of light [m/s]
  const double k = 1.3807e-23;     // Boltzmann's constant [J/K]
  const double lambda_m = lambda*1e-9; // lambda [m]
  const double lambda2 = lambda_m*lambda_m;
  const double lambda5 = lambda2*lambda_m*lambda2;
  const double c1 = 2. * h * c * c / lambda5;
  const double c2 = h * c / (lambda_m * temperature * k);
  // convert to spectral radiance in [W/m^2 / sr / nm]
  return 2.21566e-16 * c1 / (exp(c2)-1.0);
}


// Journal of Computer Graphics Techniques, Simple Analytic Approximations to
// the CIE XYZ Color Matching Functions Vol. 2, No. 2, 2013 http://jcgt.org
//Inputs:  Wavelength in nanometers
float xFit_1931( float wave )
{
  float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);
  float t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);
  float t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);
  return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);
}
float yFit_1931( float wave )
{
  float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);
  float t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);
  return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);
}
float zFit_1931( float wave )
{
  float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);
  float t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);
  return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);
}

vec3 fetch_coeff(vec3 rgb, out float b)
{
#if 0 // tiled 3D
  // TODO: trilinear interpolation!
  const uvec2 wd = textureSize(img_coeff, 0).xy;
  const uint tiles = 16;//uint(pow(wd.x, 1.0/3.0)); // cbrt(512) = 8
  const uint tilew = 256;//wd.x / tiles;             // 512 / 8 = 64

  const uvec2 x = uvec2(rgb.rg * tilew);
  const uint tile = uint(rgb.b * tilew);
  const uvec2 t = uvec2(tile % tiles, tile / tiles);

  // TODO: try gamma!
  return texelFetch(img_coeff, ivec2( t*tilew + x), 0).rgb;
#endif

  // xy chromaticity diagram
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing
  return texture(img_coeff, tc).rgb;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  if(ipos.x > params.split * imageSize(img_out).x)
  {
  const mat3 xyz_to_rec2020 = mat3(
    1.71665119, -0.66668435,  0.01763986,
   -0.35567078,  1.61648124, -0.04277061,
   -0.25336628,  0.01576855,  0.94210312);
#if 1 // moments
  float b;
  vec3 cwp   = fetch_coeff(vec3(params.temp*0.49 + 0.5, 0.5, 0.5 - params.temp*0.49), b);
  vec3 coeff = fetch_coeff(rgb, b);

  // apply saturation by blurring the spectrum. in fourier space this means
  // we multiply the coefficients by the fourier transform of the kernel.
  // this is a poisson kernel (right..?):
  vec2 exp_momc[3], eval_polyc[3];
  {
    float r = params.sat; // 1.0 + 5.0 * params.sat; // radius
    vec3 cf2 = vec3(coeff.x, coeff.y * r, coeff.z * r);
    prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, cf2);
    if(!valid(exp_momc))
      prepareReflectanceSpectrumReal3(exp_momc, eval_polyc, coeff);
  }

  const int num_l = 30;
  vec3 xyz = vec3(0);
  const vec3 norm = num_l * vec3(0.354678, 0.355529, 0.34371);
  vec2 exp_momw[3], eval_polyw[3];
  prepareReflectanceSpectrumReal3(exp_momw, eval_polyw, cwp);
#if 1
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    const float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    const float phase = lambda_to_phase(lambda);
    const float val = evaluateReflectanceSpectrum3(phase, exp_momc, eval_polyc);
    const float wht = evaluateReflectanceSpectrum3(phase, exp_momw, eval_polyw);

    // compute colour again, in xyz:
    xyz +=
      val * wht *
      vec3(
        xFit_1931(lambda),
        yFit_1931(lambda),
        zFit_1931(lambda));
  }
  xyz /= norm;
  float b2 = dot(vec3(1),xyz);
  xyz *= b/b2;
  rgb = xyz_to_rec2020*xyz;
#endif
  }
#endif
#if 0 // sigmoids
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  const float b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing
  vec3 coeff = texture(img_coeff, tc).rgb;
  const int num_l = 10;
  xyz = vec3(0);
  const vec3 norm = num_l * vec3(0.354678, 0.355529, 0.34371);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    float x = (coeff.x * lambda + coeff.y) * lambda + coeff.z;
    float y = 1. / sqrt(x * x + 1.);
    float val = 0.5 * x * y +  0.5;

    // compute colour again, in xyz:
    xyz +=
      val *
      vec3(
        xFit_1931(lambda),
        yFit_1931(lambda),
        zFit_1931(lambda));
  }
  xyz /= norm;
  float b2 = dot(vec3(1),xyz);
  xyz *= b/b2;
  rgb = xyz_to_rec2020*xyz;
  }
#endif
#if 0 // old tiled 3D map
  const float scale = max(max(1.0, rgb.r), max(rgb.g, rgb.b));
  rgb /= scale;

  // if lut is in xyz, first go there:
  // rgb = inverse(xyz_to_rec2020) * rgb;
  // TODO: fix cube lookup at boundaries!
  rgb = clamp(rgb, vec3(0.001), vec3(0.999));

  vec3 coeff = fetch_coeff(rgb);
  // const vec3 cwp   = fetch_coeff(vec3(0.8, 0.5, 0.5));
  const vec3 cwp   = fetch_coeff(vec3(params.temp*0.49 + 0.5, 0.5, 0.5 - params.temp*0.49));

  // convert to slope width domlambda
  {
    float disc = abs(4.0*coeff.x*coeff.z - coeff.y*coeff.y);
    disc = sqrt(disc);
    vec3 swz = vec3(
      - disc /  2.0,
      - disc / (2.0*coeff.x),
      - coeff.y / (2.0 * coeff.x));

    swz.y *= params.sat;

    // convert back
    coeff.x = swz.x / swz.y;  // surprisingly so does not cause trouble it seems
    coeff.y = -2.0 * coeff.x * swz.z; // causes some black dots in the blacks
    coeff.z = coeff.x * (swz.z*swz.z - swz.y*swz.y); // breaks like half the image
    // catastrophic cancellation?
    if(4.0*coeff.x*coeff.z > coeff.y*coeff.y)
      coeff.z = coeff.x * (swz.z*swz.z + swz.y*swz.y); // this case is fine
      // coeff.z = swz.x * swz.y + coeff.x * swz.z*swz.z;
  }

  const int num_l = 10;
  vec3 xyz = vec3(0);
  const vec3 norm = num_l * vec3(0.354678, 0.355529, 0.34371);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    float x = (coeff.x * lambda + coeff.y) * lambda + coeff.z;
    float y = 1. / sqrt(x * x + 1.);
    float val = 0.5 * x * y +  0.5;
    float x2 = (cwp.x * lambda + cwp.y) * lambda + cwp.z;
    float y2 = 1. / sqrt(x2 * x2 + 1.);
    float vwp = 0.5 * x2 * y2 +  0.5;

    // compute colour again, in xyz:
    xyz +=
      // float(1.0/0.0093498 * blackbody_radiation(lambda, params.temp)) * //6504.0) * 
      vwp *
      // 0.001/ float(blackbody_radiation(lambda, params.temp)) * //6504.0) * 
      // 1.0/106.8 *
      val *
      // 0.1*
      vec3(
        xFit_1931(lambda),
        yFit_1931(lambda),
        zFit_1931(lambda));
  }
  rgb = scale * ((xyz_to_rec2020)*(xyz/norm));
  }
#endif

  imageStore(img_out, ipos, vec4(rgb, 1));
}

