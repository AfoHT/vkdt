#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float split;
  float temp;
} params;


layout( // input f16 buffer rgb
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input spec coeff lut
    set = 1, binding = 1
) uniform sampler2D img_coeff;

layout( // output f16 buffer rgb
    set = 1, binding = 2
) uniform writeonly image2D img_out;

// this is sufficiently different to D65, can't use it:
double blackbody_radiation(
    double lambda,      // in [nm]
    double temperature) // in [K]
{
  const double h = 6.62606957e-34; // Planck's constant [J s]
  const double c = 299792458.0;    // speed of light [m/s]
  const double k = 1.3807e-23;     // Boltzmann's constant [J/K]
  const double lambda_m = lambda*1e-9; // lambda [m]
  const double lambda2 = lambda_m*lambda_m;
  const double lambda5 = lambda2*lambda_m*lambda2;
  const double c1 = 2. * h * c * c / lambda5;
  const double c2 = h * c / (lambda_m * temperature * k);
  // convert to spectral radiance in [W/m^2 / sr / nm]
  return 2.21566e-16 * c1 / (exp(c2)-1.0);
}


// Journal of Computer Graphics Techniques, Simple Analytic Approximations to
// the CIE XYZ Color Matching Functions Vol. 2, No. 2, 2013 http://jcgt.org
//Inputs:  Wavelength in nanometers
float xFit_1931( float wave )
{
  float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);
  float t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);
  float t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);
  return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);
}
float yFit_1931( float wave )
{
  float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);
  float t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);
  return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);
}
float zFit_1931( float wave )
{
  float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);
  float t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);
  return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);
}

vec3 fetch_coeff(vec3 rgb)
{
  // TODO: trilinear interpolation!
  const uvec2 wd = textureSize(img_coeff, 0).xy;
  const uint tiles = 16;//uint(pow(wd.x, 1.0/3.0)); // cbrt(512) = 8
  const uint tilew = 256;//wd.x / tiles;             // 512 / 8 = 64

  const uvec2 x = uvec2(rgb.rg * tilew);
  const uint tile = uint(rgb.b * tilew);
  const uvec2 t = uvec2(tile % tiles, tile / tiles);

  // TODO: try gamma!
  return texelFetch(img_coeff, ivec2( t*tilew + x), 0).rgb;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(img_in, ipos, 0).rgb;
  if(ipos.x > params.split * imageSize(img_out).x)
  {
  const mat3 xyz_to_rec2020 = mat3(
   1.71665119, -0.66668435,  0.01763986,
   -0.35567078,  1.61648124, -0.04277061,
   -0.25336628,  0.01576855,  0.94210312);

  const float scale = max(max(1.0, rgb.r), max(rgb.g, rgb.b));
  rgb /= scale;

  // if lut is in xyz, first go there:
  // rgb = inverse(xyz_to_rec2020) * rgb;
  // TODO: fix cube lookup at boundaries!
  rgb = clamp(rgb, vec3(0.001), vec3(0.999));

  const vec3 coeff = fetch_coeff(rgb);
  // const vec3 cwp   = fetch_coeff(vec3(0.8, 0.5, 0.5));
  const vec3 cwp   = fetch_coeff(vec3(params.temp*0.49 + 0.5, 0.5, 0.5 - params.temp*0.49));

  const int num_l = 10;
  vec3 xyz = vec3(0);
  const vec3 norm = num_l * vec3(0.354678, 0.355529, 0.34371);
  for(int l=0;l<num_l;l++)
  { // compute spectrum
    // float lambda = 360.0 + l/(num_l-1.0) * (830.0 - 360.0);
    float lambda = 400.0 + (l+0.5)/float(num_l) * (700.0 - 400.0);
    float x = (coeff.x * lambda + coeff.y) * lambda + coeff.z;
    float y = 1. / sqrt(x * x + 1.);
    float val = 0.5 * x * y +  0.5;
    float x2 = (cwp.x * lambda + cwp.y) * lambda + cwp.z;
    float y2 = 1. / sqrt(x2 * x2 + 1.);
    float vwp = 0.5 * x2 * y2 +  0.5;

    // compute colour again, in xyz:
    xyz +=
      // float(1.0/0.0093498 * blackbody_radiation(lambda, params.temp)) * //6504.0) * 
      vwp *
      // 0.001/ float(blackbody_radiation(lambda, params.temp)) * //6504.0) * 
      // 1.0/106.8 *
      val *
      // 0.1*
      vec3(
        xFit_1931(lambda),
        yFit_1931(lambda),
        zFit_1931(lambda));
  }
  rgb = scale * ((xyz_to_rec2020)*(xyz/norm));
  }

  imageStore(img_out, ipos, vec4(rgb, 1));
}

