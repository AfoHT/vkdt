#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

//layout(std140, set = 0, binding = 1) uniform params_t
// { } params;

layout( // input buffer rg ui8
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output f16 buffer rgba
    set = 1, binding = 1
) uniform writeonly image2D img_out;

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  // decode YUYV: two bytes per pixel for every other pixel it means u or v
  vec4 tex = texelFetch(img_in, ivec2(ipos.x/2, ipos.y), 0).rgba;
  float Y = ((ipos.x & 1) != 0) ? tex.b : tex.r;
  float u = 2.0*tex.g-1.0;
  float u = 2.0*tex.a-1.0;
  // float Y = texelFetch(img_in, ipos, 0).r;
  // float u = -1.0+2.0*texelFetch(img_in, (ipos/2)*2, 0).g;
  // float v = -1.0+2.0*texelFetch(img_in, (ipos/2)*2+1, 0).g;

  // YCbCr with limited quantization range:
  // Y = (256.0*Y - 16.0)/(235.0-16.0);
  // u = ((u+1.0)*0.5 * 256 - 16.0)/(240.0-16.0)*2.0-1.0;
  // v = ((v+1.0)*0.5 * 256 - 16.0)/(240.0-16.0)*2.0-1.0;

  // BT.601 (HDTV)
  vec3 rgb = vec3(
      Y               + 1.13983 * v,
      Y - 0.39465 * u - 0.58060 * v,
      Y + 2.03211 * u);
  mat3 rec709_to_rec2020 = mat3(
      0.62750375, 0.32927542, 0.04330267,
      0.06910828, 0.91951917, 0.0113596 ,
      0.01639406, 0.08801128, 0.89538036);
  rgb *= rec709_to_rec2020;

  imageStore(img_out, ipos, vec4(rgb, 1));
}

