#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  uvec4 nspots;
  vec4 spot[20];
  float picked[60]; // actually 3-strided colours
} params;

layout( // input picked colour buffer
    set = 1, binding = 0
) uniform usampler2D img_in;

layout( // rgb to sigmoid lut
    set = 1, binding = 1
) uniform sampler2D img_coeff;

layout( // output buffer
    set = 1, binding = 2
) uniform writeonly image2D img_out;

// TODO: put in shared.glsl?
vec3 fetch_coeff(vec3 rgb, out float b)
{
  // xy chromaticity diagram
  const mat3 rec2020_to_xyz = mat3(
    6.36958048e-01, 2.62700212e-01, 4.20575872e-11,
    1.44616904e-01, 6.77998072e-01, 2.80726931e-02,
    1.68880975e-01, 5.93017165e-02, 1.06098506e+00);
  vec3 xyz = rec2020_to_xyz * rgb;
  b = dot(vec3(1),xyz);
  vec2 tc = xyz.xy/b;
  tc.y = 1.0-tc.y; // FIXME: fix this when writing

  // bilinear interpolation, fails at blue-white-red ridge
#if 0
  return texture(img_coeff, tc).rgb;
#else
  vec2 tci = tc * textureSize(img_coeff, 0);
  vec2 uv = fract(tci);
  vec3 c0 = texelFetch(img_coeff, ivec2(tci), 0).rgb;
  vec3 c1 = texelFetch(img_coeff, ivec2(tci)+ivec2(0,1), 0).rgb;
  vec3 c2 = texelFetch(img_coeff, ivec2(tci)+ivec2(1,0), 0).rgb;
  vec3 c3 = texelFetch(img_coeff, ivec2(tci)+ivec2(1,1), 0).rgb;
  int nshaped = 0;
  vec2 w = vec2(0.0);
  vec3 r0 = vec3(0.0);
  vec3 r1 = vec3(0.0);
  if(c0.x < 0) { w.x += (1.0-uv.x)*(1.0-uv.y); r0 += (1.0-uv.x)*(1.0-uv.y)*c0; nshaped++;}
  else { w.y += (1.0-uv.x)*(1.0-uv.y); r1 += (1.0-uv.x)*(1.0-uv.y)*c0; }
  if(c1.x < 0) { w.x += uv.x*(1.0-uv.y); r0 += uv.x*(1.0-uv.y)*c1; nshaped++;}
  else w.y += uv.x*(1.0-uv.y); r1 += uv.x*(1.0-uv.y)*c1;
  if(c2.x < 0) { w.x += (1.0-uv.x)*uv.y; r0 += (1.0-uv.x)*uv.y*c2; nshaped++;}
  else w.y += (1.0-uv.x)*uv.y; r1 += (1.0-uv.x)*uv.y*c2;
  if(c3.x < 0) { w.x += uv.x*uv.y; r0 += uv.x*uv.y*c3; nshaped++;}
  else { w.y += uv.x*uv.y; r1 += uv.x*uv.y*c3;}
  if(nshaped >= 2) 
    return r0 / w.x;
  return r1 / w.y;
#endif
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = vec3(0.0);

  for(int i=0;i<params.nspots.x;i++)
  {
    // read colour from texture
    vec3 picked_rgb = vec3(
      texelFetch(img_in, ivec2(i, 0), 0).r/pow(2.0, 30.0),
      texelFetch(img_in, ivec2(i, 1), 0).r/pow(2.0, 30.0),
      texelFetch(img_in, ivec2(i, 2), 0).r/pow(2.0, 30.0));

    // or else read colour from params (requires round trip to cpu)?
    // params.pick[]

    float b;
    vec3 coeff = fetch_coeff(picked_rgb, b);

    float lambda = 360.0 + ipos.x/float(imageSize(img_out).x) * (830.0 - 360.0);
    float x = (coeff.x * lambda + coeff.y) * lambda + coeff.z;
    float y = 1. / sqrt(x * x + 1.);
    float val = 0.5 * x * y +  0.5;

    float t = 4.;
    float d = abs((1.0-val) * imageSize(img_out).y - ipos.y);
    rgb = max(rgb, picked_rgb * vec3(smoothstep(t, 0.0, d)));
  }
  imageStore(img_out, ipos, vec4(rgb, 1));
}

