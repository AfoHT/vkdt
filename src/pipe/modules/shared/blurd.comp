#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout( // input buffer array
    set = 1, binding = 0
) uniform sampler2D img_in[];

layout( // output buffer array
    set = 1, binding = 1
) uniform writeonly image2D img_out[];

layout(push_constant, std140) uniform push_t
{
  ivec2 dir;  // (0,1) or (1,0)
  int idx;    // iteration number
} push;

void
main()
{
  ivec2 opos = ivec2(gl_GlobalInvocationID);
  int idx = int(gl_GlobalInvocationID.z);
  if(any(greaterThanEqual(opos, imageSize(img_out[idx])))) return;

  vec2 res = vec2(textureSize(img_in[idx], 0));
  vec2 uv;
  vec4 color = vec4(0.0);
  if(push.idx > 0)
  {
    uv = vec2(opos + vec2(0.5)) / res;
    vec2 off1 = push.idx * vec2(1.3333333333333333) * push.dir / res;
    color += textureLod(img_in[idx], uv - off1, 0) * 0.29411764705882354;
    color += textureLod(img_in[idx], uv + off1, 0) * 0.29411764705882354;
    color += textureLod(img_in[idx], uv, 0) * 0.35294117647058826;
    color *= 1.0/.94117647058823534;
  }
  else
  {
    // yx swizzle because we want pixel center in y (no blur) if we blur in x
    uv = vec2(opos * (push.dir + vec2(1, 1)) + .5*push.dir.yx) / res;
    vec2 off1 = vec2( 1.0) * push.dir / res;
    vec2 off2 = vec2( 2.0) * push.dir / res;
    color += textureLod(img_in[idx], uv, 0);// * 0.29411764705882354;
    color += textureLod(img_in[idx], uv + off1, 0);// * 0.29411764705882354;
    color += textureLod(img_in[idx], uv + off2, 0);// * 0.35294117647058826;
    color *= 1.0/3.0;
  }

  imageStore(img_out[idx], opos, color);
}

