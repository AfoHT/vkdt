#version 450
#extension GL_ARB_separate_shader_objects : enable

const uint GROUP_SIZE = 128;

layout(binding = 0) uniform ub {
  uint iteration;
  uint max_iteration;
  uint wd;
  uint ht;
  uint min_samples; 
};

layout(binding = 1) buffer b_in {
  float bin[];
};
layout(binding = 2) buffer b_out {
  float bout[];
};
layout(binding = 3) buffer b_out2 {
  float bout2[];
};

layout(local_size_x = GROUP_SIZE) in;
void main()
{
  const uint x = gl_GlobalInvocationID.x;
  const uint y = gl_GlobalInvocationID.y;
  const uint ind = 3*(x+y*wd);
  const int step = 1<<(iteration-1); // first iteration doesn't smooth at all
  // const float mins = min_samples / float(step*step);
  // const float mins_prev = min_samples / float(step*step/4.0f);
  // const float ft[5] = { 1.0f / 16.0f, 4.0f / 16.0f, 6.0f / 16.0f, 4.0f / 16.0f, 1.0f / 16.0f };
  // un-normalised version to keep sample count in right range:
  const float ft[5] = { 0.25f, 1.0f, 6.0f/4.0f, 1.0f, 0.25f };
  // could use two separable passes but that would be more work
  if(x < wd && y < ht)
  {
    if(iteration == 0)
    {
      bout[ind] = bin[ind];
      // if enough samples found in our surroundings, remember iteration
      if(bout[ind] >= min_samples)//mins)
        bout[ind+1] = 1.0f;
      else
        bout[ind+1] = 0.0f;
    }
    else // start smoothing
    {
      bout[ind] = 0.0f;
      for(int j=-2;j<=2;j++) for(int i=-2;i<=2;i++)
      {
        int ii = clamp(step*i+int(x), 0, int(wd)-1), jj = clamp(step*j+int(y), 0, int(ht)-1);
        uint ind2 = 3*(ii + jj*wd);
        bout[ind] += bout2[ind2]*ft[i+2]*ft[j+2];
      }
      // just copy iteration number, if any:
      bout[ind+1] = bout2[ind+1];
      // if enough samples found in our surroundings, remember iteration
      // but write it only if the previous iteration didn't suffice:
      if(bout2[ind+1] == 0.0f && bout[ind] >= min_samples)
      {
        // how many iterations would we need to take us to exactly 100%?
        float last = sqrt(bout2[ind]);
        float curr = sqrt(bout [ind]);
        float delta = 1.0f/(curr - last); // difference in one iteration
        bout[ind+1] = iteration +
          clamp((sqrt(float(min_samples))-last) * delta, 0.0f, 1.0f);
      }
    }
  }
}

