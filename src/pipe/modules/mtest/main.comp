#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 0) uniform global_t
{
  uint frame;
} global;
// layout(std140, set = 0, binding = 1) uniform params_t
// {} params;

layout( // output
    set = 1, binding = 0
) uniform writeonly image2D img_out;


// try to generate some feature-happy texture
vec2 hash(vec2 p)
{
  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
  return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}
float noise(in vec2 p)
{
  const float K1 = 0.366025404;
  const float K2 = 0.211324865;
  vec2 i = floor(p + (p.x+p.y)*K1);
  vec2 a = p - i + (i.x+i.y)*K2;
  vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
  vec2 b = a - o + K2;
  vec2 c = a - 1.0 + 2.0*K2;
  vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);
  vec3 n = h*h*h*h*vec3(dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
  return dot(n, vec3(70.0));
}
float fbm(vec2 n)
{
  const  mat2 m = mat2(1.6, 1.2, -1.2, 1.6);
  float total = 0.0, amplitude = 1.;
  for(int i=0;i<7;i++)
  {
    total += noise(n) * amplitude;
    n = m*n;
    amplitude *= 0.4;
  }
  return total;
}

// tiny encryption algorithm random numbers
vec2
encrypt_tea(uvec2 arg)
{
  const uint key[] = {
    0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e
  };
  uint v0 = arg[0], v1 = arg[1];
  uint sum = 0;
  uint delta = 0x9e3779b9;

  #pragma unroll
  for(int i = 0; i < 16; i++) {
    sum += delta;
    v0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);
    v1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);
  }
  return vec2(v0/(0xffffffffu+1.0), v1/(0xffffffffu+1.0));
}

vec2 next_rand(inout uvec2 seed)
{
  seed.y++;
  return encrypt_tea(seed);
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 sz = imageSize(img_out);
  vec3 rgb = vec3(0.2f);
  int wd = 100;
  if(((ipos.x/wd + ipos.y/wd) & 1) == 0)
    rgb = vec3(0.8f);

  rgb = vec3(0.2, 0.2, 1.0) * (1.+fbm(ipos * 0.005))/2.0;
  // rgb = vec3(0);

  vec2 c = vec2(sz/2);
  // const float speed = 0.04 * 1.0/360.0 * 2.0 * 3.1415926;
  const float speed = 1.0/360.0 * 2.0 * 3.1415926;
  c += sz/4 * vec2(
      sin(global.frame * speed),
      cos(global.frame * speed + 0.3));

  float r = 150;
  float d2 = dot(ipos-c, ipos-c);
  if(d2 <= r*r) 
  {
    rgb = vec3(.9, 0.2, 0.3) * (.8+fbm((ipos-c) * 0.05))/2.5;
    // int wd = 10;
    // if((((ipos.x - int(c.x))/wd + (ipos.y - int(c.y))/wd) & 1) == 0)
    //   rgb = vec3(1.0f);
    // else
    //   rgb = vec3(0.0);
  }
#if 1
  // add some noise:
  const float amp = 0.02;
  vec2 ru = encrypt_tea(
      uvec2(1024*(1024*ipos.y + ipos.x) + global.frame, 37));
  // box mueller transform to get std normal
  vec2 rg = sqrt(-2.0f*log(ru.x)) * vec2(
      cos(2.0f*3.1415962f * ru.y),
      sin(2.0f*3.1415962f * ru.y));
  rgb.g += amp * rg.x; // sigma * Z: additive white gaussian noise
  rgb.r += amp * rg.y; // sigma * Z: additive white gaussian noise
  // rgb.b += 0.04 * (rg.x + rg.y);
#endif
  imageStore(img_out, ipos, vec4(rgb, 1));
}

