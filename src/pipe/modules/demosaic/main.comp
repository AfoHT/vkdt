#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// layout(push_constant, std140) uniform IterationInfo {
//   uint iteration;
// } push;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 0) uniform params_t
{
  roi_t ri;
  roi_t ro;
  uint filters;
} params;


layout( // input uint16 buffer rggb
    set = 1, binding = 0
) uniform usampler2D img_in;

layout( // output f32 buffer rgb
    set = 1, binding = 1, rgba32f
) uniform image2D img_out;

// demosaic reduced size. run on output dimensions, gather all colours from
// input buffer (this might be 3x3 for xtrans).
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

  uint c0 = texelFetch(img_in, 2*ipos, 0).r;
  uint c1 = texelFetch(img_in, 2*ipos+ivec2(0,1), 0).r;
  uint c2 = texelFetch(img_in, 2*ipos+ivec2(1,0), 0).r;
  uint c3 = texelFetch(img_in, 2*ipos+ivec2(1,1), 0).r;
  vec4 rgba = vec4(c0, (c1+c2)/2.0, c3, 1.0);
  // TODO: for x-trans, we'll need to average 3x3 blocks and maybe have
  // even more headaches about alignment of patterns (what is green?)
  imageStore(img_out, ipos, rgba);
}

// now the real work:
// 1) subsample following the half-size routine above
// 2) estimate gaussian params from xx^t in 3x3 nbhood around each pixel, clamp eigenvalues
// 3) interpolate covariance matrices for every hi-res pixel
// 4) gather gaussians from neighbours
#if 0 // TODO

void
subsample_bayer()
{
  // this kernel is called with roi on low res:
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

  uint c0 = texelFetch(img_in, 2*ipos, 0).r;
  uint c1 = texelFetch(img_in, 2*ipos+ivec2(0,1), 0).r;
  uint c2 = texelFetch(img_in, 2*ipos+ivec2(1,0), 0).r;
  uint c3 = texelFetch(img_in, 2*ipos+ivec2(1,1), 0).r;
  // TODO: if(param.filters == ) xtrans?
  vec4 gray = (c1 + c2 + c3 + c4)*0.25f;
  imageStore(img_gray, ipos, rgba);
}

#if 0
static inline void getEVDSymmetric2x2(double pOutEigenvalues[2], double pOutEigenvectors[4], const double pMatrix[4]) {
	// Define some short hands for the matrix entries
	double a = pMatrix[0];
	double b = pMatrix[1];
	double c = pMatrix[3];
	// Compute coefficients of the characteristic polynomial
	double pHalf = -0.5 * (a + c);
	double q = a*c - b*b;
	// Solve the quadratic
	double discriminant_root = sqrt(pHalf * pHalf - q);
	pOutEigenvalues[0] = -pHalf + discriminant_root;
	pOutEigenvalues[1] = -pHalf - discriminant_root;
	// Subtract a scaled identity matrix to obtain a rank one matrix
	double a0 = a - pOutEigenvalues[0];
	double b0 = b;
	double c0 = c - pOutEigenvalues[0];
	// The column space of this matrix is orthogonal to the first eigenvector 
	// and since the eigenvectors are orthogonal themselves, it agrees with the 
	// second eigenvector. Pick the longer column to avoid cancellation.
	double squaredLength0 = a0*a0 + b0*b0;
	double squaredLength1 = b0*b0 + c0*c0;
	double squaredLength;
	if (squaredLength0 > squaredLength1) {
		pOutEigenvectors[2] = a0;
		pOutEigenvectors[3] = b0;
		squaredLength = squaredLength0;
	}
	else {
		pOutEigenvectors[2] = b0;
		pOutEigenvectors[3] = c0;
		squaredLength = squaredLength1;
	}
	// If the eigenvector is exactly zero, both eigenvalues are the same and the 
	// choice of orthogonal eigenvectors is arbitrary
	pOutEigenvectors[2] = (squaredLength == 0.0) ? 1.0 : pOutEigenvectors[2];
	squaredLength = (squaredLength == 0.0) ? 1.0 : squaredLength;
	// Now normalize
	double invLength = 1.0 / sqrt(squaredLength);
	pOutEigenvectors[2] *= invLength;
	pOutEigenvectors[3] *= invLength;
	// And rotate to get the other eigenvector
	pOutEigenvectors[0] =  pOutEigenvectors[3];
	pOutEigenvectors[1] = -pOutEigenvectors[2];
}
#endif

void
estimate_covariance()
{
  // this kernel is called with roi on low res:
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

  float g00 = texelFetch(img_gray_in, ipos+ivec2(-1,-1)).r;
  float g01 = texelFetch(img_gray_in, ipos+ivec2(-1, 0)).r;
  float g02 = texelFetch(img_gray_in, ipos+ivec2(-1, 1)).r;
  float g10 = texelFetch(img_gray_in, ipos+ivec2( 0,-1)).r;
  float g11 = texelFetch(img_gray_in, ipos+ivec2( 0, 0)).r;
  float g12 = texelFetch(img_gray_in, ipos+ivec2( 0, 1)).r;
  float g20 = texelFetch(img_gray_in, ipos+ivec2( 1,-1)).r;
  float g21 = texelFetch(img_gray_in, ipos+ivec2( 1, 0)).r;
  float g22 = texelFetch(img_gray_in, ipos+ivec2( 1, 1)).r;
  vec2 var = (g00-g11)*vec2(-1,-1)*vec2(-1,-1) +
             (g01-g11)*vec2(-1, 0)*vec2(-1, 0) +
             (g02-g11)*vec2(-1, 1)*vec2(-1, 1) +
             (g10-g11)*vec2( 0,-1)*vec2( 0,-1) +
             (g11-g11)*vec2( 0, 0)*vec2( 0, 0) +
             (g12-g11)*vec2( 0, 1)*vec2( 0, 1) +
             (g20-g11)*vec2( 1,-1)*vec2( 1,-1) +
             (g21-g11)*vec2( 1, 0)*vec2( 1, 0) +
             (g22-g11)*vec2( 1, 1)*vec2( 1, 1);
  float cov= (g00-g11)*-1*-1 +
             (g01-g11)*-1* 0 +
             (g02-g11)*-1* 1 +
             (g10-g11)* 0*-1 +
             (g11-g11)* 0* 0 +
             (g12-g11)* 0* 1 +
             (g20-g11)* 1*-1 +
             (g21-g11)* 1* 0 +
             (g22-g11)* 1* 1;
  // TODO: construct matrix, do SVD, clamp eigenvalues, write back
  imageStore(img_cov, ipos, vec4(var, cov, 1.0));
}

void
gather()
{
  // this kernel is called with roi on high res:
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

  // TODO: make sure we have an interpolating/magnifying image sampler!
  vec2 tc = vec2(ipos) / vec2(params.ro.roi);
  vec4 cov = texture(img_cov, tc);

  vec4 rgba;
  imageStore(img_out, ipos, rgba);
}
#endif
