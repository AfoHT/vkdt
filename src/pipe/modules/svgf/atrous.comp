#version 460
#extension GL_GOOGLE_include_directive    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

// layout(std140, set = 0, binding = 1) uniform params_t
// { } params;

layout( // input
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // output
    set = 1, binding = 1
) uniform writeonly image2D img_out;

vec4 gamma(vec4 f)
{
  return vec4(
      f.x < 0.0 ? f.x : pow(f.x, 0.8),
      f.y < 0.0 ? f.y : pow(f.y, 0.8),
      f.z < 0.0 ? f.z : pow(f.z, 0.8),
      f.w < 0.0 ? f.w : pow(f.w, 0.8));
}

float edge(vec4 s, vec4 c0, vec4 c1)
{
    /* float w = exp(-dot(wc*(col-rgb),wc*(col-rgb))) * (1.0-t)/4.0; */ \
    /* float w = exp(-dot(wc*abs(col-rgb),vec3(1.0))) * (1.0-t)/4.0; */ \
  // return exp(-dot(s*abs(gamma(c0)-gamma(c1)),vec3(1.0)));
  return clamp(1.0-0.5*dot(s*abs(gamma(c0)-gamma(c1)), vec4(1.0)), 0.0, 1.0);
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 sz = textureSize(img_in, 0).xy;

  // 5 tap flower filter
  // const float t = 36.0/256.0; // preserve weight of center pixel, we're leaving away 8 samples in the boundary of the support.
  // const float t = 0.3; // a bit sharper
  const float t = 0.2;
  vec4 rgb = texelFetch(img_in, ipos, 0);
  vec4 sum = t * rgb;
  float wgt = t;

  const float sigma = 10.0; // XXX noise model per pixel
  vec4 wc = vec4(vec3(1./sigma), 1.0);
#define lookup(O) \
  do { \
  vec4 col = texture(img_in, (ipos + O)/vec2(sz)); \
  float w = edge(wc, col, rgb) * (1.0-t)/4.0; \
  sum += w * col; \
  wgt += w; \
  } while(false)
  lookup(vec2(0.5 + 1.2, 0.5 + 0.4));
  lookup(vec2(0.5 - 1.2, 0.5 - 0.4));
  lookup(vec2(0.5 + 0.4, 0.5 - 1.2));
  lookup(vec2(0.5 - 0.4, 0.5 + 1.2));
  rgb = sum / wgt;
#undef lookup

  // sort image to write positions so we can iterate the filter
  ivec2 off = ivec2(ipos.x & 1, ipos.y & 1) * (imageSize(img_out)+ivec2(1))/2;
  ipos = ipos / 2 + off;
#if 0
# reiner's trick:
half_img_size = len(img_ping) / 2
half_img_mask = half_img_size - 1
is_uneven = (x & 1)
offset = is_uneven * half_img_size
new_x = x / 2 + offset
+ itr == 0:
+   #new_x = new_x ^ (half_img_mask * is_uneven)
+   new_x = offset + (half_img_mask - new_x_local)
#endif

  imageStore(img_out, ipos, rgb);
}
