#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "config.h"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{ 
  float alpha;
  float taa;
  float lalpha;
  float ltaa;
} params;

layout(set = 1, binding = 0) uniform sampler2D img_mv;     // motion vectors
layout(set = 1, binding = 1) uniform sampler2D img_prevl;  // previous light
layout(set = 1, binding = 2) uniform sampler2D img_prevb;  // previous beauty
layout(set = 1, binding = 3) uniform sampler2D img_light;  // current light
layout(set = 1, binding = 4) uniform sampler2D img_albedo; // current albedo

layout(set = 1, binding = 5) uniform writeonly image2D img_out;      // new beauty frame
layout(set = 1, binding = 6) uniform writeonly image2D img_lightout; // combined light only

ivec2 eaw3_tc(ivec2 tc, ivec2 sz)
{
#if SVGF_OFF==1
  return tc;
#else
  sz += ivec2(1);
  tc = tc / 2 + ivec2(tc.x & 1, tc.y & 1) * sz/2;
  tc = tc / 2 + ivec2(tc.x & 1, tc.y & 1) * sz/2;
  tc = tc / 2 + ivec2(tc.x & 1, tc.y & 1) * sz/2;
  tc = tc / 2 + ivec2(tc.x & 1, tc.y & 1) * sz/2;
  return tc;
#endif
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 sz = textureSize(img_light, 0).xy;
  vec2 mv = texelFetch(img_mv, ipos, 0).rg;
  vec3 L  = texelFetch(img_light, eaw3_tc(ipos,           sz), 0).rgb;
  vec3 Lo = texelFetch(img_prevl, eaw3_tc(ivec2(ipos+mv), sz), 0).rgb;
  vec3 prevb = texelFetch(img_prevb, ivec2(ipos+mv), 0).rgb;

#if SVGF_OFF==0
  L = mix(L, Lo, params.lalpha); // exponential moving average with aligned old light
#if 1 // taa box clamping old light vs. new light
  {
  // vec3 mL1  = vec3(0.0f);
  // vec3 mL2  = vec3(0.0f);
  vec3 maL1 = vec3(0.0f);
  vec3 maL2 = vec3(0.0f);
  const int r = 1;
  for(int yy = -r; yy <= r; yy++) {
    for(int xx = -r; xx <= r; xx++) {
      vec3 a = texelFetch(img_albedo, ipos + ivec2(xx, yy), 0).rgb;
      // vec3 L = texelFetch(img_light, eaw3_tc(ipos + ivec2(xx, yy), sz), 0).rgb;
      maL1 += a*L;
      maL2 += a*a*L*L;
      // mL1 += L;
      // mL2 += L*L;
    }
  }
  maL1 /= (2.0 * r + 1) * (2.0 * r + 1);
  maL2 /= (2.0 * r + 1) * (2.0 * r + 1);
  // mL1  /= (2.0 * r + 1) * (2.0 * r + 1);
  // mL2  /= (2.0 * r + 1) * (2.0 * r + 1);

  // vec3 sigma = sqrt(max(vec3(0), mL2 - mL1 * mL1));
  // float thresh = params.ltaa;
  // Lo = clamp(Lo, max(vec3(0), mL1 - thresh * sigma), mL1 + thresh * sigma);
  vec3 sigma = sqrt(max(vec3(0), maL2 - maL1 * maL1));
  float thresh = params.taa;
  // FIXME: if we want to clamp this, we need to take rec2020 moments!
  // XXX can transform the moments once at the end, because linear.
  prevb = clamp(prevb, max(vec3(0), maL1 - thresh * sigma), maL1 + thresh * sigma);
  }
#endif
#endif

  vec3 albedo = texelFetch(img_albedo, ipos, 0).rgb; // multiply albedo
  vec3 beauty = L * albedo;

  // convert linear rec709 to linear rec2020
  mat3 M = mat3(
      0.62750375, 0.06910828, 0.01639406,
      0.32927542, 0.91951916, 0.08801125,
      0.04330266, 0.0113596 , 0.89538035);
  beauty = M * beauty;

  // beauty = mix(beauty, prevb, params.alpha);
  imageStore(img_out, ipos, vec4(beauty, 1));
  imageStore(img_lightout, eaw3_tc(ipos, sz), vec4(L, 1));
}

