#version 460
#extension GL_GOOGLE_include_directive    : enable

#include "shared.glsl"
#include "render3d.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

// layout(std140, set = 0, binding = 1) uniform params_t
// { } params;

layout(set = 1, binding = 0) uniform sampler2D img_irr;
layout(set = 1, binding = 2) uniform sampler2D img_alb;
layout(set = 1, binding = 3) uniform sampler2D img_gbuf;
layout(set = 1, binding = 1) uniform writeonly image2D img_out;

vec4 gamma(vec4 f)
{
  return vec4(
      f.x < 0.0 ? f.x : pow(f.x, 0.8),
      f.y < 0.0 ? f.y : pow(f.y, 0.8),
      f.z < 0.0 ? f.z : pow(f.z, 0.8),
      f.w < 0.0 ? f.w : pow(f.w, 0.8));
}

float edge(vec4 s, vec4 c0, vec4 c1)
{
    /* float w = exp(-dot(wc*(col-rgb),wc*(col-rgb))) * (1.0-t)/4.0; */ \
    /* float w = exp(-dot(wc*abs(col-rgb),vec3(1.0))) * (1.0-t)/4.0; */ \
  // return exp(-dot(s*abs(gamma(c0)-gamma(c1)),vec3(1.0)));
  return clamp(1.0-0.5*dot(s*abs(gamma(c0)-gamma(c1)), vec4(1.0)), 0.0, 1.0);
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 sz = textureSize(img_irr, 0).xy;

  // temporal std dev estimation:
  vec4  gbuf   = texelFetch(img_gbuf, ipos, 0);
  float sigma  = sqrt(max(0, gbuf.w - gbuf.z*gbuf.z)) + 1e-8;
  vec3  normal = geo_decode_normal(floatBitsToUint(gbuf.x));
  float depth  = gbuf.y;

  // 5 tap flower filter
  // const float t = 36.0/256.0; // preserve weight of center pixel, we're leaving away 8 samples in the boundary of the support.
  // const float t = 0.3; // a bit sharper
  const float t = 0.2;
  vec4 rgba;
  rgba.rgb = texelFetch(img_irr, ipos, 0).rgb;
  vec3 alb = texelFetch(img_alb, ipos, 0).rgb;
  rgba.a = dot(vec3(1), alb);
  vec4 sum = t * rgba;
  float wgt = t;

  vec4 wc = vec4(vec3(.1/sigma), 1.0);
#define lookup(O) \
  do { \
  vec4 col = vec4(\
                   texture(img_irr, (ipos+O)/vec2(sz)).rgb,   \
      dot(vec3(1), texture(img_alb, (ipos+O)/vec2(sz)).rgb)   \
      * dot(normal, geo_decode_normal(floatBitsToUint(texelFetch(img_gbuf, ipos, 0).x))) \
      * abs(depth - texelFetch(img_gbuf, ipos, 0).y) \
      ); \
  float w = edge(wc, col, rgba) * (1.0-t)/4.0; \
  sum += w * col; \
  wgt += w; \
  } while(false)
  lookup(vec2(0.5 + 1.2, 0.5 + 0.4));
  lookup(vec2(0.5 - 1.2, 0.5 - 0.4));
  lookup(vec2(0.5 + 0.4, 0.5 - 1.2));
  lookup(vec2(0.5 - 0.4, 0.5 + 1.2));
  rgba = sum / wgt;
#undef lookup

  // sort image to write positions so we can iterate the filter
  ivec2 off = ivec2(ipos.x & 1, ipos.y & 1) * (imageSize(img_out)+ivec2(1))/2;
  ipos = ipos / 2 + off;

  imageStore(img_out, ipos, rgba);
}

