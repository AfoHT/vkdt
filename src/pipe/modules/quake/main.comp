#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#extension GL_EXT_ray_tracing             : enable
#extension GL_EXT_ray_query               : enable

#include "shared.glsl"
#include "shared/render3d.glsl"
#include "config.h"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 0) uniform global_t
{ 
  int frame;
} global;

#include "water.glsl"

layout(std140, set = 0, binding = 1) uniform params_t
{ 
  vec4 cam_x;
  vec4 cam_w;
  vec4 cam_u;
  int spp;
  int torch;
  int water;
  uint sky_rt, sky_bk, sky_lf, sky_ft, sky_up, sky_dn;
  float cl_time; // quake time
  int   ref;     // use reference sampling
} params;

// layout(push_constant, std140) uniform push_t
// { } push;

layout(set = 1, binding = 0) uniform writeonly image2D img_irradiance;

// TODO: make this an array (and support more instances for decals etc)
layout(std430, set = 1, binding = 1) buffer sssbo_t
{
  uint v[]; // extra geo info for static geo
} stcssbo;

layout(std430, set = 1, binding = 2) buffer dssbo_t
{
  uint v[]; // extra geo info for dynamic geo
} dynssbo;

layout(set = 1, binding = 3) uniform sampler2D img_tex[];
layout(set = 1, binding = 4) uniform sampler2D img_blue;

layout(set = 1, binding = 5) uniform writeonly image2D img_albedo;

layout(set = 1, binding = 6) uniform usampler2D img_nee_in;
layout(set = 1, binding = 7) uniform writeonly uimage2D img_nee_out;
layout(set = 1, binding = 8) uniform sampler2D img_mv;

layout(set = 1, binding =  9) uniform sampler2D img_gbuf_in;
layout(set = 1, binding = 10) uniform writeonly image2D img_gbuf_out;

layout(set = 2, binding = 0) uniform accelerationStructureEXT rt_accel;

layout(set = 2, binding = 1) buffer buf_vtx_t
{ // 3x float vertex data for every instance
  float v[];
} buf_vtx[];

layout(set = 2, binding = 2) buffer buf_idx_t
{ // index data for every instance
  uint i[];
} buf_idx[];

// importance sample the blackman harris pixel filter.
// has 1.5px radius support
vec2 filter_bh_sample(vec2 rand)
{
  vec2 res = vec2(cos(rand.y*M_PI*2.0), sin(rand.y*M_PI*2.0));
  float r = 0.943404 * asin(0.636617 * asin(sqrt(rand.x))); // surprisingly good fit to inverse cdf
  return res * r;
}

vec3 envmap(in vec3 w)
{
  if(params.sky_lf == -1u)
  { // classic quake sky
    vec2 st = 0.5 + 0.5*vec2(-w.y,w.x) / abs(w.z);
    vec2 t = global.frame * vec2(0.002, 0.001);
    vec4 bck = texelFetch(img_tex[nonuniformEXT(params.sky_rt)], ivec2(mod(st+0.1*t, vec2(1))*textureSize(img_tex[nonuniformEXT(params.sky_rt)], 0)), 0);
    vec4 fnt= texelFetch(img_tex[nonuniformEXT(params.sky_bk)], ivec2(mod(st+t, vec2(1))*textureSize(img_tex[nonuniformEXT(params.sky_bk)], 0)), 0);
    vec3 tex = mix(bck.rgb, fnt.rgb, fnt.a);
    return tex*tex;
  }
  else
  { // cubemap: gfx/env/*{rt,bk,lf,ft,up,dn}
    // vec3 sundir = normalize(vec3(1, 1, 1)); // this where the moon is in ad_azad
    // vec3 sundir = normalize(vec3(1, -1, 1)); // this comes in more nicely through the windows for debugging
    vec3 sundir = normalize(vec3(1, -1, 1)); // ad_tears
    const float k0 = 4.0, k1 = 30.0, k2 = 4.0, k3 = 3000.0;
    vec3 emcol = vec3(0.0);
    emcol  = vec3(0.50, 0.50, 0.50) * /*(k0+1.0)/(2.0*M_PI)*/ pow(0.5*(1.0+dot(sundir, w)), k0);
    emcol += vec3(1.00, 0.70, 0.30) * /*(k1+1.0)/(2.0*M_PI)*/ pow(0.5*(1.0+dot(sundir, w)), k1);
    // emcol += 1000*vec3(1.00, 1.00, 1.00) * /*(k1+1.0)/(2.0*M_PI)*/ pow(0.5*(1.0+dot(sundir, w)), k3);
    emcol += 100.0*vec3(1.1, 1.0, 0.9)*vmf_eval(k3, dot(sundir, w));
    emcol += vec3(0.20, 0.08, 0.02) * /*(k2+1.0)/(2.0*M_PI)*/ pow(0.5*(1.0-w.z), k2);
    // emcol *= 2.0;
    int m = 0;
    if(abs(w.y) > abs(w.x) && abs(w.y) > abs(w.z)) m = 1;
    if(abs(w.z) > abs(w.x) && abs(w.z) > abs(w.y)) m = 2;
    uint side = 0;
    vec2 st;
    if     (m == 0 && w.x > 0) { side = params.sky_rt; st = 0.5 + 0.5*vec2(-w.y, -w.z) / abs(w.x);} // rt
    else if(m == 0 && w.x < 0) { side = params.sky_lf; st = 0.5 + 0.5*vec2( w.y, -w.z) / abs(w.x);} // lf
    else if(m == 1 && w.y > 0) { side = params.sky_bk; st = 0.5 + 0.5*vec2( w.x, -w.z) / abs(w.y);} // bk
    else if(m == 1 && w.y < 0) { side = params.sky_ft; st = 0.5 + 0.5*vec2(-w.x, -w.z) / abs(w.y);} // ft
    else if(m == 2 && w.z > 0) { side = params.sky_up; st = 0.5 + 0.5*vec2(-w.y,  w.x) / abs(w.z);} // up
    else if(m == 2 && w.z < 0) { side = params.sky_dn; st = 0.5 + 0.5*vec2(-w.y, -w.x) / abs(w.z);} // dn
    ivec2 tc = 
      clamp(ivec2(textureSize(img_tex[nonuniformEXT(side)], 0)*st),
          ivec2(0), textureSize(img_tex[nonuniformEXT(side)], 0)-1);
    vec3 tex = texelFetch(img_tex[nonuniformEXT(side)], tc, 0).rgb;
    emcol += tex*tex; // mul "un-gamma"d sky texture
    return emcol;
  }
}

float mrand(inout uint seed)
{ // Algorithm "xor" from p. 4 of Marsaglia, "Xorshift RNGs"
  seed ^= seed << 13;
  seed ^= seed >> 17;
  seed ^= seed << 5;
  return seed / 4294967296.0;
}

vec4 xrand(inout uint seed, ivec2 p)
{
  // cp shift based on seed
  return mod(texelFetch(img_blue, p, 0) + vec4(mrand(seed), mrand(seed), mrand(seed), mrand(seed)), vec4(1.0));
}

struct intersection_t
{ // almost minimal intersection descriptor
  int  instid;
  int  primid;
  uint uv;     // unpackHalf2x16
  float t;     // intersection distance
};

struct raycast_res_t
{ // stores whatever a ray cast needs to report
  intersection_t opaque;
  intersection_t water;
};

struct material_info_t
{ // initialised hit point to work with
  vec3 x;
  vec3 n, du, dv; // shading frame
  vec3 ng;        // geo normal, if different to n
  vec2 st;        // texture coordinates
  uint mat;       // albedo texture
  uint matfb;     // "fullbright" texture/emission
  uint matgl;     // glossy texture, if any
  uint matnd;     // normal/displacement texture, if any
  float alpha;    // if > 0.0 overwrite texture alpha
  float t;        // intersection distance
  uint flags;     // none, lava, slime, tele, water
  vec3 albedo;
  vec3 emission;
  uint bsdf;      // bsdf model id
  vec3 bsdf_param;// extra bsdf params, anisotropic roughness etc
#if 0
  int instid;
  int primid;
  vec2 uv;
#endif
};

intersection_t
prepare_intersection(
    rayQueryEXT rq)
{
  intersection_t inter;
  inter.instid = rayQueryGetIntersectionInstanceIdEXT(rq, false);     // which of our ssbo
  inter.primid = rayQueryGetIntersectionPrimitiveIndexEXT(rq, false); // primitive inside instance
  inter.uv     = packHalf2x16(rayQueryGetIntersectionBarycentricsEXT(rq, false));
  inter.t      = rayQueryGetIntersectionTEXT(rq, false);
  return inter;
}

material_info_t
prepare_material_info(
    vec3           x,      // incoming ray origin.
    vec3           w,      // incoming ray direction.
    raycast_res_t  inter)  // identify geo intersection
{
  material_info_t m;
  vec3 b;
  b.yz = unpackHalf2x16(inter.opaque.uv);
  b.x = 1.0-b.z-b.y;
  int i = 7*inter.opaque.primid;
  vec3 n0, n1, n2;
  vec2 st0, st1, st2;
  bool brush_model = false;
  if(inter.opaque.instid == 0)
  { // dyn geo
    m.mat   =  dynssbo.v[i+6]&0xfff;
    m.alpha = (dynssbo.v[i+6]>>12)/15.0;
    m.matfb = (dynssbo.v[i+6]>>16) & 0xfff;
    m.flags =  dynssbo.v[i+6]>>28;
    m.matgl = m.matnd = 0;
    brush_model = (dynssbo.v[i+1] == 0xffffffff);
    if(brush_model)
    {
      m.matgl = dynssbo.v[i+0]&0xffff;
      m.matnd = dynssbo.v[i+0]>>16;
    }
    else
    {
      n0 = geo_decode_normal(dynssbo.v[i+0]);
      n1 = geo_decode_normal(dynssbo.v[i+1]);
      n2 = geo_decode_normal(dynssbo.v[i+2]);
    }
    st0 = unpackHalf2x16(dynssbo.v[i+3]);
    st1 = unpackHalf2x16(dynssbo.v[i+4]);
    st2 = unpackHalf2x16(dynssbo.v[i+5]);
    m.st = mat3x2(st0, st1, st2) * b;
  }
  else
  { // static geo
    brush_model = (stcssbo.v[i+1] == 0xffffffff);
    m.mat   =  stcssbo.v[i+6]&0xfff;
    m.alpha = (stcssbo.v[i+6]>>12)/15.0;
    m.matfb = (stcssbo.v[i+6]>>16) & 0xfff;
    m.flags =  stcssbo.v[i+6]>>28;
    if(brush_model)
    {
      m.matgl = stcssbo.v[i+0]&0xffff;
      m.matnd = stcssbo.v[i+0]>>16;
    }
    else
    {
      n0 = geo_decode_normal(stcssbo.v[i+0]);
      n1 = geo_decode_normal(stcssbo.v[i+1]);
      n2 = geo_decode_normal(stcssbo.v[i+2]);
    }
    st0 = unpackHalf2x16(stcssbo.v[i+3]);
    st1 = unpackHalf2x16(stcssbo.v[i+4]);
    st2 = unpackHalf2x16(stcssbo.v[i+5]);
    m.st = mat3x2(st0, st1, st2) * b;
  }
  // more precise intersection point by using vertices + barycentrics
  uint i0 = buf_idx[inter.opaque.instid].i[3*inter.opaque.primid+0];
  uint i1 = buf_idx[inter.opaque.instid].i[3*inter.opaque.primid+1];
  uint i2 = buf_idx[inter.opaque.instid].i[3*inter.opaque.primid+2];
  vec3 v0 = vec3(
      buf_vtx[inter.opaque.instid].v[3*i0+0],
      buf_vtx[inter.opaque.instid].v[3*i0+1],
      buf_vtx[inter.opaque.instid].v[3*i0+2]);
  vec3 v1 = vec3(
      buf_vtx[inter.opaque.instid].v[3*i1+0],
      buf_vtx[inter.opaque.instid].v[3*i1+1],
      buf_vtx[inter.opaque.instid].v[3*i1+2]);
  vec3 v2 = vec3(
      buf_vtx[inter.opaque.instid].v[3*i2+0],
      buf_vtx[inter.opaque.instid].v[3*i2+1],
      buf_vtx[inter.opaque.instid].v[3*i2+2]);
  m.x = mat3(v0, v1, v2) * b;
  m.t = m.mat == 0xfff ? T_MAX-1.0 : inter.opaque.t;
  m.ng = normalize(cross(v2-v0,v1-v0));
  if(!brush_model) // only alias models have these normals
  { // now fix shading normals below horizon and terminator problem:
#if 0
    if(dot(w,n0) > 0) n0 -= w*dot(w,n0);
    if(dot(w,n1) > 0) n1 -= w*dot(w,n1);
    if(dot(w,n2) > 0) n2 -= w*dot(w,n2);
    m.n = normalize(mat3(n0, n1, n2) * b);
    vec3 tmpu = m.x - v0, tmpv = m.x - v1, tmpw = m.x - v2;
    float dotu = min(0.0, dot(tmpu, n0));
    float dotv = min(0.0, dot(tmpv, n1));
    float dotw = min(0.0, dot(tmpw, n2));
    tmpu -= dotu*n0;
    tmpv -= dotv*n1;
    tmpw -= dotw*n2;
    m.x += mat3(tmpu, tmpv, tmpw) * b;
#else // XXX FIXME: shading normals are fubared!
    m.n = n0 = n1 = n2 = m.ng;
#endif
  }
  else
  { // brushmodels have no vertex normals
    m.n = n0 = n1 = n2 = m.ng;
  }

  m.albedo   = vec3(0);
  m.emission = vec3(0);
  if(m.mat == 0xfff)
  { // marked as sky
    m.albedo = vec3(0.0);
    m.emission = envmap(w);
    m.n = -w; // sky has no normal
    m.x = x + (T_MAX-1.0) * w; // sky is far away
  }
  else
  {
    if(m.flags > 0)
    { // all esoteric surfaces warp
      m.st = vec2(
          m.st.x + 0.2*sin(m.st.y*2.0 + params.cl_time * 0.01),
          m.st.y + 0.2*sin(m.st.x*2.0 + params.cl_time * 0.01));
    }
    ivec2 tc = ivec2(textureSize(img_tex[nonuniformEXT(m.mat)], 0)*mod(m.st, vec2(1.0)));
    tc = clamp(tc, ivec2(0), textureSize(img_tex[nonuniformEXT(m.mat)], 0)-1);
    m.albedo = texelFetch(img_tex[nonuniformEXT(m.mat)], tc, 0).rgb;
    m.albedo *= m.albedo; // "un-gamma"
    m.emission = m.matfb > 0 ? texelFetch(img_tex[nonuniformEXT(m.matfb)], tc, 0).rgb : vec3(0.0);
    m.emission *= m.emission;
  }
  if     (m.flags == 1) m.emission = 20.0*m.albedo; // lava
  else if(m.flags == 2) m.emission =  0.5*m.albedo; // slime
  else if(m.flags == 3) m.emission =  5.0*m.albedo; // tele
  else if(m.mat == 0xfff) m.emission = m.emission;//(exp2(m.emission*10.0)-1.0);
  else m.emission = 10.0*(exp2(m.emission*10.0)-1.0);
#if 1
  if(brush_model && m.matnd > 0)
  { // apply normal map
    ivec2 tc = ivec2(textureSize(img_tex[nonuniformEXT(m.matnd)], 0)*mod(m.st, vec2(1.0)));
    tc = clamp(tc, ivec2(0), textureSize(img_tex[nonuniformEXT(m.matnd)], 0)-1);
    vec3 du = v2 - v0, dv = v1 - v0;
    vec2 duv1 = st2 - st0, duv2 = st1 - st0;
    float det = duv1.x * duv2.y - duv2.x * duv1.y;
    if(abs(det) > 1e-8)
    {
      m.du =  normalize(( duv2.y * du - duv1.y * dv) / det);
      m.dv = -normalize((-duv2.x * du + duv1.x * dv) / det);
    }
    m.n = normalize(mat3(m.du, m.dv, m.n) * ((texelFetch(img_tex[nonuniformEXT(m.matnd)], tc, 0).xyz - vec3(0.5)) * vec3(2)));
    vec3 up = vec3(1,0,0);
    if(abs(m.n.x) > abs(m.n.y)) up = vec3(0,1,0);
    m.du = normalize(cross(up, m.n));
    m.dv = normalize(cross(m.du, m.n));
    if(dot(w,m.n) > 0) m.n -= w*dot(w,m.n);
  }
  else
#endif
  { // init tangent frame
    if(dot(w, m.n) > 0) m.n = -m.n; // never happens except when it does (transparent surfaces/sky)
    vec3 up = vec3(1,0,0);
    if(abs(m.n.x) > abs(m.n.y)) up = vec3(0,1,0);
    m.du = normalize(cross(up, m.n));
    m.dv = normalize(cross(m.du, m.n));
  }
  if(dot(w, m.ng) > 0) m.ng = -m.ng; // never happens except when it does (transparent surfaces/sky)

  m.bsdf = 1; // slight rough lobe too
  m.bsdf_param = vec3(0.01);

#if 0 // does not work with water (no uvs) and not well in general (primids inconsistent)
  m.instid = inter.opaque.instid;
  m.primid = inter.opaque.primid;
  m.uv = b.yz;
#endif

#if WATER_MODE==WATER_MODE_FULL
  if(inter.water.t < inter.opaque.t)
  { // potentially closer water intersection
    uint seed = uint(1337000*(17*m.x.x+m.x.y));
    float rand = mrand(seed);
    i = 7*inter.water.primid;
    uint flags = stcssbo.v[i+6]>>28;
    float t = water_intersect(params.cl_time, x+(inter.water.t+rand*0.01)*w, w, WATER_DEPTH, flags == 4);
    if(inter.water.t + t < inter.opaque.t && inter.water.t + t > 0.03)
    {
      m.bsdf = 1; // rough microfacet
      m.bsdf_param = vec3(0.002);
      m.t = inter.water.t + t;
      m.x = x + m.t*w;
      vec4 wn = water_normal(params.cl_time, m.x, WATER_DEPTH);
      m.ng = wn.xyz;
      // m.flags = 4;
      if(dot(w, m.ng) > 0) m.ng = -m.ng; // never happens except when it does (transparent surfaces/sky)
      m.n = m.ng;
      vec3 up = vec3(1,0,0);
      if(abs(m.n.x) > abs(m.n.y)) up = vec3(0,1,0);
      m.du = normalize(cross(up, m.n));
      m.dv = normalize(cross(m.du, m.n));
      m.flags =  flags;//stcssbo.v[i+6]>>28;

#if 0
      m.mat   =  stcssbo.v[i+6]&0xfff;
      m.alpha = (stcssbo.v[i+6]>>12)/15.0;
      m.matfb = (stcssbo.v[i+6]>>16) & 0xfff;
      m.matgl =  stcssbo.v[i+0]&0xffff;
      m.matnd =  stcssbo.v[i+0]>>16;
      m.st = m.x.xy*0.01;
      // m.st = vec2(
      //     m.st.x + 0.2*sin(m.st.y*2.0 + global.frame * 0.01),
      //     m.st.y + 0.2*sin(m.st.x*2.0 + global.frame * 0.01));
      ivec2 tc = ivec2(textureSize(img_tex[nonuniformEXT(m.mat)], 0)*mod(m.st, vec2(1.0)));
      tc = clamp(tc, ivec2(0), textureSize(img_tex[nonuniformEXT(m.mat)], 0)-1);
      m.albedo = texelFetch(img_tex[nonuniformEXT(m.mat)], tc, 0).rgb;
      m.albedo *= m.albedo; // "un-gamma"
#else
      m.albedo = vec3(1.0);
#endif
      // m.albedo = mix(vec3(0.1, 0.5, 0.8), vec3(0.8, 0.9, 0.9), pow(wn.w/WATER_DEPTH, 2));
      // m.albedo *= mix(vec3(1.0), vec3(1, 2, 2), smoothstep(0.0, 1.0, clamp(wn.w/WATER_DEPTH, 0, 1.0)));
      m.emission = vec3(0.0);
    }
  }
#elif WATER_MODE==WATER_MODE_NORMALS
  if(m.flags == 4)
  {
    m.bsdf = 1; // rough microfacet
    m.bsdf_param = vec3(0.002);
    vec4 wn = water_normal(m.x, WATER_DEPTH);
    m.ng = wn.xyz;
    if(dot(w, m.ng) > 0) m.ng = -m.ng; // never happens except when it does (transparent surfaces/sky)
    m.n = m.ng;
    vec3 up = vec3(1,0,0);
    if(abs(m.n.x) > abs(m.n.y)) up = vec3(0,1,0);
    m.du = normalize(cross(up, m.n));
    m.dv = normalize(cross(m.du, m.n));
  }
#endif

  return m;
}

vec3 nee_torch(
    in const vec3 lpos,
    in const vec3 x,
    in const vec3 rgb, // TODO: replace by some material that we can evaluate for directions
    in const vec3 n,
    inout uint seed,
    in ivec2 rp)
{
  rayQueryEXT rq;
  vec3 ws;
  float ldist = distance(lpos, x);
  float ao = 0.0;
  vec4 rand = xrand(seed, rp);
  ws = normalize(lpos + 2.0*rand.xyz - x);
#if 1
  rayQueryInitializeEXT(rq, rt_accel,
      gl_RayFlagsNoneEXT,
      // gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT,
      0xFF, x, 2e-2, ws, ldist-2e-2);
  while(rayQueryProceedEXT(rq))
  {
    if (rayQueryGetIntersectionTypeEXT(rq, false) == gl_RayQueryCandidateIntersectionTriangleEXT)
    {
      int instance_id = rayQueryGetIntersectionInstanceIdEXT(rq, false); // which of our ssbo
      int pi = rayQueryGetIntersectionPrimitiveIndexEXT(rq, false); // primitive inside instance
      vec3 b;
      b.yz = rayQueryGetIntersectionBarycentricsEXT(rq, false);
      b.x = 1.0-b.z-b.y;
      // if(min(b.x,min(b.y,b.z)) < 0.05) rayQueryConfirmIntersectionEXT(rq); // wireframe
      int i = 7*pi;
      uint mat = 0;
      vec2 st;
      if(instance_id == 0)
      {
        mat   = dynssbo.v[i+6]&0xfff;
        vec2 st0 = unpackHalf2x16(dynssbo.v[i+3]);
        vec2 st1 = unpackHalf2x16(dynssbo.v[i+4]);
        vec2 st2 = unpackHalf2x16(dynssbo.v[i+5]);
        st = mat3x2(st0, st1, st2) * b;
      }
      else
      {
        mat   = stcssbo.v[i+6]&0xfff;
        vec2 st0 = unpackHalf2x16(stcssbo.v[i+3]);
        vec2 st1 = unpackHalf2x16(stcssbo.v[i+4]);
        vec2 st2 = unpackHalf2x16(stcssbo.v[i+5]);
        st = mat3x2(st0, st1, st2) * b;
      }
      ivec2 tc = ivec2(textureSize(img_tex[nonuniformEXT(mat)], 0)*mod(st, vec2(1.0)));
      tc = clamp(tc, ivec2(0), textureSize(img_tex[nonuniformEXT(mat)], 0)-1);
      vec4 diffcol = texelFetch(img_tex[nonuniformEXT(mat)], tc, 0);
      // if(any(greaterThan(diffcol.rgb, vec3(0.0))) || diffcol.a > 0.666)
      if(diffcol.a > 0.666)
        rayQueryConfirmIntersectionEXT(rq);
    }
  }
  if(rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT) ao ++;
#endif
  ao = clamp(ao, 0.0, 1.0);
  float edf = 4000.0*pow(abs(dot(-ws, params.cam_w.xyz)), 45.0);
  return (1.0-ao) * rgb * abs(dot(ws,n)) * edf * vec3(0.2, 0.7, 1.0)/(ldist*ldist); // light with falloff
}

raycast_res_t cast_ray(rayQueryEXT rq, vec3 x, vec3 w, const float t_max)
{
  raycast_res_t res;
  res.water.t  = t_max;
  res.opaque.t = t_max;
  rayQueryInitializeEXT(rq, rt_accel, gl_RayFlagsNoneEXT, 0xFF, x, 1e-3, w, t_max);
  while(rayQueryProceedEXT(rq))
  {
    if (rayQueryGetIntersectionTypeEXT(rq, false) == gl_RayQueryCandidateIntersectionTriangleEXT)
    {
      int instance_id = rayQueryGetIntersectionInstanceIdEXT(rq, false); // which of our ssbo
      int pi = rayQueryGetIntersectionPrimitiveIndexEXT(rq, false); // primitive inside instance
      vec3 b;
      b.yz = rayQueryGetIntersectionBarycentricsEXT(rq, false);
      b.x = 1.0-b.z-b.y;
      int i = 7*pi;
      uint mat = 0;
      uint flags = 0;
      uint alpha = 0;
      vec2 st;
      if(instance_id == 0)
      {
        mat   = dynssbo.v[i+6]&0xfff;
        alpha = dynssbo.v[i+6]>>12;
        flags = dynssbo.v[i+6]>>28;
        vec2 st0 = unpackHalf2x16(dynssbo.v[i+3]);
        vec2 st1 = unpackHalf2x16(dynssbo.v[i+4]);
        vec2 st2 = unpackHalf2x16(dynssbo.v[i+5]);
        st = mat3x2(st0, st1, st2) * b;
      }
      else
      {
        mat   = stcssbo.v[i+6]&0xfff;
        alpha = stcssbo.v[i+6]>>12;
        flags = stcssbo.v[i+6]>>28;
        vec2 st0 = unpackHalf2x16(stcssbo.v[i+3]);
        vec2 st1 = unpackHalf2x16(stcssbo.v[i+4]);
        vec2 st2 = unpackHalf2x16(stcssbo.v[i+5]);
        st = mat3x2(st0, st1, st2) * b;
      }
      if(flags > 0) st = vec2(
          st.x + 0.2*sin(st.y*2.0 + global.frame * 0.01),
          st.y + 0.2*sin(st.x*2.0 + global.frame * 0.01));
      ivec2 tc = ivec2(textureSize(img_tex[nonuniformEXT(mat)], 0)*mod(st, vec2(1.0)));
      tc = clamp(tc, ivec2(0), textureSize(img_tex[nonuniformEXT(mat)], 0)-1);
      vec4 diffcol = texelFetch(img_tex[nonuniformEXT(mat)], tc, 0);

#if WATER_MODE==WATER_MODE_FULL
      if((flags == 4) || (flags == 5))
      { // only remember closest water intersection, but don't confirm.
        // we need the opaque geo behind it in case the procedural water pattern
        // ends up not intersecting after all.
        if(rayQueryGetIntersectionTEXT(rq, false) < res.water.t)
          res.water = prepare_intersection(rq);
      }
      else if(flags != 4 && flags != 5)
#endif
      if(diffcol.a > 0.666)
      {
        res.opaque = prepare_intersection(rq);
        rayQueryConfirmIntersectionEXT(rq);
      }
    }
  }
  return res;
  // always the case, quake maps are closed:
  // return (rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

// propagate ray through (single bounce) specular chain
material_info_t
propagate_ray(
    vec3 x,                   // ray origin
    vec3 w,                   // ray direction
    inout bool underwater,    // start under water? (see params.water for camera rays)
    inout material_info_t m,  // intermediate vertex (if any, or else same as returned)
    float xi)                 // [0,1) random number for R/T lobe selection
{
  rayQueryEXT rq;
  const float t_max = T_MAX;
  raycast_res_t res = cast_ray(rq, x, w, t_max);
  m = prepare_material_info(x, w, res);
#if WATER_MODE==WATER_MODE_OFF
  return m;
#else
  if(m.flags != 4 && m.flags != 5/* && m.alpha > 0.5*/) return m; // no water no transmission, simple
  
  // randomly sample reflective/termination vs specular transmit
  float ior = 1.33;
  // critical angle for out->inside is 90 degrees grazing
  // critical angle for in->outside is where eta^2 * (1.0-dot(N,I)^2) >= 1
  const float r = 0.02;
  float fresnel;
  if(underwater) fresnel = r + (1.0-r) * pow(clamp(ior*ior*(1.0 - dot(-w, m.n)*dot(-w, m.n)), 0.0, 1.0), 5.0);
  else           fresnel = r + (1.0-r) * pow(clamp(1.0 - dot(-w, m.n), 0.0, 1.0), 5.0);
  if(xi < fresnel) return m; // use R lobe (non-singular bsdf, whatever was set in m)
  vec3 wo;
  if(underwater) wo = refract(w, m.n, ior);
  else           wo = refract(w, m.n, 1.0/ior);
  if(all(equal(wo, vec3(0.0)))) return m; // total internal reflection
  underwater = !underwater;
  res = cast_ray(rq, m.x-m.n*0.01, wo, t_max);
  return prepare_material_info(m.x, wo, res);
#endif
}

struct mc_state_t
{
  vec3  y;              // world space position of light source point
  vec3  n;              // world space light normal
  float f;              // observed measurement contribution until there (bsdf * G * Le)
  float kappa;          // concentration parameter for vMF
#if 0
  uint instid;          // 16 bit instance id
  uint primid;          // 16 bit primitive id
  vec2 uv;              // 2x8 bit barycentrics
#endif
};

mc_state_t mc_state_new()
{
  mc_state_t r;
  r.y = vec3(0);
  r.n = vec3(0);
  r.f = 0.0;
  r.kappa = 0;
  return r;
}

// return only the cosines, not the distance squared part
float G_cosines(vec3 x, vec3 nx, vec3 y, vec3 ny)
{
  vec3 d = normalize(y - x);
  return max(0, dot(d, nx))*max(0, dot(-d, ny));
}

// pass shading point first, remote/light second (for sky detection)
float G_term(vec3 x, vec3 nx, vec3 y, vec3 ny)
{
  vec3 d = y - x;
  float r2 = dot(d, d);
  if(r2 > (T_MAX-1.0-100)*(T_MAX-1.0-100)) // this has got to be the sky
    return max(0, dot(d, nx));
  d = normalize(d);
  return max(0, dot(d, nx))*max(0, dot(-d, ny))/max(1e-6, r2);
}

uvec4 mc_state_encode(mc_state_t r)
{
  return uvec4(
#if 1
      packHalf2x16(r.y.xy),
      packHalf2x16(vec2(r.y.z, r.f)),
      uint(r.kappa),
      geo_encode_normal(r.n));
#else
      r.instid | (r.primid << 4),
      // (packSnorm4x8(r.uv.xyxy) & 0xffff) | (packHalf2x16(vec2(r.f))<<16),
      packHalf2x16(vec2(r.f)),
      uint(r.kappa),
      packHalf2x16(r.uv));
#endif
}

#if 0
vec3 mc_state_get_ws_pos(uint instid, uint primid, vec2 uv)
{
  vec3 b;
  b.yz = uv;
  b.x = 1.0-b.z-b.y;
  uint i0 = buf_idx[instid].i[3*primid+0];
  uint i1 = buf_idx[instid].i[3*primid+1];
  uint i2 = buf_idx[instid].i[3*primid+2];
  vec3 v0 = vec3(
      buf_vtx[instid].v[3*i0+0],
      buf_vtx[instid].v[3*i0+1],
      buf_vtx[instid].v[3*i0+2]);
  vec3 v1 = vec3(
      buf_vtx[instid].v[3*i1+0],
      buf_vtx[instid].v[3*i1+1],
      buf_vtx[instid].v[3*i1+2]);
  vec3 v2 = vec3(
      buf_vtx[instid].v[3*i2+0],
      buf_vtx[instid].v[3*i2+1],
      buf_vtx[instid].v[3*i2+2]);
  return mat3(v0, v1, v2) * b;
}
#endif

mc_state_t mc_state_decode(uvec4 enc)
{
  mc_state_t r = mc_state_new();
  vec2 h = unpackHalf2x16(enc.y);
  r.y.xy = unpackHalf2x16(enc.x);
  r.y.z  = h.x;
  r.f    = h.y;
  r.kappa = enc.z;
  r.n = geo_decode_normal(enc.w);
#if 0
  r.primid = enc.x>>4;
  r.instid = enc.x & 0xf;
  r.uv     = unpackHalf2x16(enc.w);//vec2(0.5);//unpackSnorm4x8(enc.y).xy;
  r.f      = h.y;
  mc_state_get_ws_pos(r);
#endif
  return r;
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_irradiance)))) return;

  uint seed = 19937 * global.frame;
  // today my bluenoise textures are borken. wtf.
  // uint seed = 13370000 * ipos.x + ipos.y * 70000 + global.frame * 19937;
  const ivec2 rp = ivec2(mod(ipos, textureSize(img_blue, 0)));
  vec2 mv = texelFetch(img_mv, ipos, 0).rg;

  vec3 alb = vec3(0.0); // albedo
  vec3 irr = vec3(0.0); // estimator for incoming "irradiance", i.e. everything divided by albedo
  // XXX 64 looks worse than 16, 8 starts to be wonky and 4 has none of the grids in s1.sav:
  // XXX too long chains/high spp probably means not enough diffuse/bsdf samples to discover things
  // XXX too low means uh? kappa adaptation can't work?
  // XXX still multi-light mixtures are wonky!
  const int spp = 4; // needs to be a compile time constant (use specialisation?)
  vec3 rad[spp]; // radiance per sample
  vec3 lco[spp]; // light source coordinates
  vec4 par[spp]; // sampling pdf parameters (mean, kappa)

  vec2 v1_nd; // vertex 1 after camera, depth and normal for gbuffer

  mc_state_t curr = mc_state_new(); // zero current state
  mc_state_t tent = mc_state_new(); // tentative new state

  vec3 lpos = vec3(0.0); // torch light pos, depending on camera
  intersection_t inter;
  material_info_t m0, m1, me, mg;
  vec4 rand = xrand(seed, rp);
  seed = uint(70000 * rand.x);
  float frame = global.frame;// + 0.5*rand.x; // 180 degree shutter
  vec3 rgb_cam = vec3(1.0);
  vec3 w_cam; // ray direction from camera
  { // camera setup:
    m0.x = params.cam_x.xyz;
    vec3 f = params.cam_w.xyz;
    vec3 t = -params.cam_u.xyz * float(imageSize(img_irradiance).y)/float(imageSize(img_irradiance).x);
    vec3 r = -normalize(cross(f, t));

    lpos = m0.x + 1*f + 10*t + 20*r;

    vec2 off = filter_bh_sample(rand.yz);
    vec2 uv = (ipos+off)/imageSize(img_irradiance) - 0.5;
    if(params.water > 0)
      uv = vec2(
          uv.x + 0.02*sin(uv.y*5.0 + params.cl_time * 0.01),
          uv.y + 0.02*sin(uv.x*5.0 + params.cl_time * 0.01));
    w_cam = normalize(0.45*f + r*uv.x + t*uv.y);
    m0.n = f;
    m0.x += w_cam * 0.02; // push a bit to avoid problems with some level-end cameras
  }

  rayQueryEXT rq;
  vec4 trans = vec4(0.0); // cannot do this for std quake maps if "r_vis 1"
  bool compute_indirect = true;

  bool cam_underwater = params.water > 0;
  m1 = propagate_ray(m0.x, w_cam, cam_underwater, mg, rand.w);
  v1_nd.x = uintBitsToFloat(geo_encode_normal(mg.n)); // normal
  v1_nd.y = length(mg.x - params.cam_x.xyz);          // depth
  // raycast_res_t res = cast_ray(rq, m0.x, w_cam, 10000.0);
  // if(res.opaque.t < 10000.0)
  if(m1.t < T_MAX)
  { // ray intersected geometry, init material state and tangent frame
    // m1 = prepare_material_info(m0.x, w_cam, res);
    // sky is "far" away
    const float T = exp(-m1.t * 3.);
    // TODO: if underwater (params.water) attenuate a bit more
    rgb_cam *= mix(vec3(0.2, 0.4, 0.9), vec3(1.0), T);
    // rgb_cam = mix(trans.rgb, rgb_cam, trans.w);

    if(any(greaterThan(m1.emission, vec3(0.0))))
    { // have >0 radiance sample on second vertex
      irr = vec3(0.01); // but be sure that albedo * irradiance stays put.
                  // alb += 100 * m1.emission;
      alb = 10.0 * m1.emission; // looks shit either way :|
      compute_indirect = false;
    }
    else alb = m1.albedo; // directly visible albedo
    // else alb = mod(0.05 * mc_state_get_ws_pos(m1.instid, m1.primid, m1.uv), vec3(1)); // this works
    // else alb = vec3((m1.primid % 256)/256.0); // are not staying consistent between frames :/
    // else alb = vec3(pow(abs(dot(m1.n,w_cam)), 10)); // debug normals
    // else alb = vec3(pow(abs(dot(geo_decode_normal(geo_encode_normal(m1.n)),w_cam)), 10)); // debug normals
    // else alb = mod(m1.x*0.05, vec3(1)); // debug world space position

    me = m1; // store g-buffer-like primary ray result

    if(compute_indirect && (params.torch == 1)) // next event estimation to torch:
      irr += nee_torch(lpos, m1.x, rgb_cam, m1.n, seed, rp);

    // indirect rays, splitting trajectories here
    if(compute_indirect) // direct lights need no indirect lighting computation
    for(int s=0;s<spp;s++)
    {
      float pdf_w = 1.0;
      m0 = me;       // restore camera point, direction, contribution
      vec3 w = w_cam;
      vec3 rgb = rgb_cam;
      rad[s] = vec3(0.0);
      for(int b=0;b<1;b++) // indirect bounces
      {
        rand = xrand(seed, rp);
        bool use_vmf = (params.ref == 0) && (s > 0);
        if(tent.f == 0) use_vmf = false;
        if(use_vmf)
        {
          w = vmf_sample(tent.kappa, rand.xy);
          vec3 mu = normalize(tent.y-m0.x);
          vec3 up = vec3(1,0,0), du, dv;
          if(abs(mu.x) > abs(mu.y)) up = vec3(0,1,0);
          du = normalize(cross(up, mu));
          dv = normalize(cross(du, mu));
          w = w.x * du + w.y * dv + w.z * mu;
          pdf_w = vmf_eval(tent.kappa, dot(w, mu));
          float dotn = dot(w, m0.n);
          if(dotn <= 0.0) use_vmf = false; // fall back to bsdf if under surface
          rgb *= dotn; // we do not sample this (as diffuse/bsdf does) so we need to multiply
          par[s] = vec4(tent.y, tent.kappa);
        }
        if(!use_vmf)
        { // sample independent new ray direction
          w = bsdf_sample(m0.bsdf, w_cam, m0.du, m0.dv, m0.n, m0.bsdf_param, rand.xy);
          w = normalize(w); // paranoia/numerical jitter over bounces
          pdf_w = bsdf_pdf(m0.bsdf, w_cam, m0.du, m0.dv, m0.n, w, m0.bsdf_param); // uniform projected solid angle
          par[s] = vec4(0.0);//vec4(m0.n, 0.0); // normal is clear from gbuf
        }
        // rgb *= bsdf_eval(m0.bsdf, w_cam, m0.du, m0.dv, m0.n, w, m0.bsdf_param); // bsdf without albedo
        rgb *= bsdf_eval(me.bsdf, w_cam, me.du, me.dv, me.n, w, me.bsdf_param); // bsdf without albedo

        if(dot(w, m0.ng) <= 0.0) rgb = vec3(0.0); // kill under geo surface paths

        bool underwater = cam_underwater;
        m1 = propagate_ray(m0.x, w, underwater, mg, rand.w);
        // trans = vec4(1.0);
        // res = cast_ray(rq, m0.x, w, 10000.0);
        // if(res.opaque.t < 10000.0)
        if(m1.t < T_MAX)
        { // ray intersected geometry, init material state and tangent frame
          // m1 = prepare_material_info(m0.x, w, res);
          const float T = exp(-m1.t * 3.);
          rgb *= mix(vec3(0.2, 0.4, 0.9), vec3(1.0), T);
          // rgb = mix(trans.rgb, rgb, trans.w);

          // vertex area measure pdf of x (new vertex)
          // XXX could use the generalised geometry term in case mg != m1:
          const float G = G_cosines(m0.x, m0.n, m1.x, m1.n);
          const float pdf = pdf_w * G;

          // handle intersection:
          // * accumulate direct albedo and indirect irradiance channels
          // * successful nee sample: store nee state in registers
          if(b == 0 && any(greaterThan(m1.emission, vec3(0.0))))
          { // update nee sampling state
            // metropolis hastings step:
            // update state of this pixel by sampling forward and back pdf:
            // include bsdf, look worse:
            // float f = max(rgb.x * m1.emission.x, max(rgb.y * m1.emission.y, rgb.z * m1.emission.z))/pdf_w;
            float f = max(m1.emission.x, max(m1.emission.y, m1.emission.z))/pdf_w;
            // float a = min(1.0, f * G / (tent.f * G_term(m0.x, m0.n, tent.y, tent.n)));
            float a = min(1.0, f * G / (tent.f * G_cosines(m0.x, m0.n, tent.y, tent.n)));
            // float a = min(1.0, f / tent.f);
            rad[s] = rgb * m1.emission; // store for balance heuristic/cmis
            lco[s] = mg.x; // aim at position on watersurface, if any
            if(tent.f == 0.0)
            { // sampled bsdf to get here? insert distance based heuristic as starting point:
              tent.kappa = clamp(800.0 + 900.0*m1.t, 100, 200000); // XXX total distance?
              if(m1.mat == 0xfff) tent.kappa = 50; // sky is smooth
              tent.f = f;
              tent.y = mg.x;
              tent.n = mg.n;
            }
            // XXX TODO: also if G_term was 0
            if(curr.f == 0.0 || rand.z < a)
            { // update markov chain state for this pixel:
              curr = tent;
              curr.f = f;
              curr.y = mg.x;      // create new lobe around good sample
              curr.n = mg.n;

#if 0
              curr.primid = mg.primid;
              curr.instid = mg.instid;
              curr.uv     = mg.uv;
#endif
              // okay this was a hit! so we can try to smooth out a bit more to explore the surroundings too:
              tent.kappa = max(100.0, tent.kappa * 0.5);
            } // this was a miss! make the lobe sharper so we increase the chances of intersecting a small light:
            else
            { // rejected, maybe try again with different kappa (if not replaced by nbhood)
              tent.kappa = min(200000.0, tent.kappa * 2.0);
#if 0
              tent.primid = mg.primid;
              tent.instid = mg.instid;
              tent.uv     = mg.uv;
#endif
            }
          }
          // XXX clearly different results, looks worse:
          // tent = curr; // rejected state means the markov chain stays

          m0 = m1; // advance path vertex
        } // end if cast ray intersected anything
        else break; // nothing intersected, can't go on
      } // end bounces

      if(global.frame > 10)
      {
        // float G = max(0, -dot(me.n, tent.n));//G_term(me.x, me.n, tent.y, tent.n);
        float G = G_cosines(me.x, me.n, tent.y, tent.n);
        float sum = tent.f*G; // XXX disregarding current tent looks better/mixes more (??)
#if 1 // random
        for(int i=0;i<5;i++) // helps explore difficult cases but is expensive
        {
          rand = xrand(seed, rp);
          ivec2 off = ivec2(15 * (2.0*rand.xy-1.0)) + 
                      ivec2(15 * (2.0*rand.zw-1.0));
#elif 0 //dense
        for(int j=-16;j<=16;j+=2) for(int i=-16;i<=16;i+=2)
        {
          ivec2 off = ivec2(i, j);
#elif 1 // fixed pattern
        for(int i=0;i<13;i++)
        {
          const ivec2 ofs[] = {ivec2(-2, 6), ivec2(6, 2), ivec2(2, -6), ivec2(-2, -6),
            ivec2(-1, -1), ivec2(0, -1), ivec2(1, -1),
            ivec2(-1,  0), ivec2(0,  0), ivec2(1,  0),
            ivec2(-1,  1), ivec2(0,  1), ivec2(1,  1)};
          ivec2 off = ofs[12-i];
#else // just our very own center pixel
        {
          ivec2 off = ivec2(0);
#endif
#if 0     // gbuffer based culling experiments. not conclusive. what would be good is to distinguish
          // between first hit and after-water-propagation hit (store sign bit in depth?)
          vec4 gbuf = texelFetch(img_gbuf_in, ivec2(ipos+mv+off), 0);
          vec3 n = geo_decode_normal(floatBitsToUint(gbuf.x));
          float dp = gbuf.y, dq = length(me.x - params.cam_x.xyz);
          float w_n = pow(max(0.0, dot(n, me.n)), 128.0);
          float w_z = 1.0;//exp(-abs(dp-dq) / 10.0);
          if(w_n * w_z > 0.2)
#endif
          {
            // rand = xrand(seed, rp);
            float rnd = mrand(seed);
            mc_state_t t2 = mc_state_decode(texelFetch(img_nee_in, ivec2(ipos+mv+off), 0));
            // float G2 = 1;//dot(me.n,t2.n)>0? 0.0 : 1.0; //max(0, -dot(me.n, t2.n));//G_term(me.x, me.n, t2.y, t2.n);
            float G2 = G_cosines(me.x, me.n, t2.y, t2.n);
            // if(tent.f*G == 0 || rnd < (G2 * t2.f) / (G * tent.f))
            // if(G == 0 || rand.z < G2 / G)
            // if(rand.z < 0.5)
            // if(tent.f == 0 || rnd < t2.f / tent.f)
            // if(tent.f == 0 || rnd < t2.f / (t2.f + sum)) // XXX reservoir style resampling: markov depends on order?
            if(tent.f == 0 || rnd < t2.f*G2 / (t2.f*G2 + sum))
              tent = t2;
            sum += t2.f*G2;
          }
        }
      }
    } // end spp for indirect rays
  } // end if intersect primary ray

  // apply cmis:
  if(compute_indirect) for(int s=0;s<spp;s++)
  {
    float pdf = bsdf_pdf(me.bsdf, w_cam, me.du, me.dv, me.n, normalize(lco[s]-me.x), me.bsdf_param);
    for(int t=1;t<spp;t++)
    {
      if(par[t].w == 0.0)
        pdf += bsdf_pdf(me.bsdf, w_cam, me.du, me.dv, me.n, normalize(lco[s]-me.x), me.bsdf_param);
      else
        pdf += vmf_eval(par[t].w, dot(normalize(lco[s] - me.x), normalize(par[t].xyz - me.x)));
    }
    if(any(greaterThan(rad[s], vec3(0.0))))
      irr += rad[s] / pdf;
  }

  vec4 gbuf = texelFetch(img_gbuf_in, ivec2(ipos+mv), 0);
  gbuf.x = uintBitsToFloat(geo_encode_normal(me.n)); // normal
  gbuf.y = length(me.x - params.cam_x.xyz);          // depth
  gbuf.z = mix(length(irr),  gbuf.z, 0.9);           // biased first  moment
  gbuf.w = mix(dot(irr,irr), gbuf.w, 0.9);           // biased second moment
  imageStore(img_gbuf_out, ipos, gbuf);

  imageStore(img_nee_out,    ipos, mc_state_encode(curr));
  imageStore(img_irradiance, ipos, vec4(irr, 1));
  imageStore(img_albedo,     ipos, vec4(alb, 1));
}

