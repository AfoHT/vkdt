#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

// layout(std140, set = 0, binding = 1) uniform params_t
// { } params;

// layout(push_constant, std140) uniform push_t
// { } push;

layout(
    set = 1, binding = 0
) uniform sampler2D img_in;

layout(
    set = 1, binding = 1
) uniform sampler2D weights;

layout(
    set = 1, binding = 2
) uniform writeonly image2D img_out;

// performs a 5x5 "blur" convolution given the weights in the according texture.
// input and output channels are 3
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  vec3 rgb = texelFetch(weights, ivec2(25, 0), 0).rgb;
  for(int j=-2;j<=2;j++) for(int i=-2;i<=2;i++)
  {
    vec3 tex = texture(img_in, (ipos+0.5+ivec2(i,j))/textureSize(img_in, 0)).rgb;
    ivec2 tc = ivec2((j+2)+i+2, 0); 
    vec3 c0 = texelFetch(weights, tc+ivec2(0, 0), 0).rgb;
    vec3 c1 = texelFetch(weights, tc+ivec2(0, 1), 0).rgb;
    vec3 c2 = texelFetch(weights, tc+ivec2(0, 2), 0).rgb;
    mat3 M = mat3(c0, c1, c2);
    rgb += M * tex;
  }
  // apply (leaky) relu or not:
  // rgb *= mix(1.0, push.relu, lessThan(rgb < vec3(0.0)));

  imageStore(img_out, ipos, vec4(rgb, 1.0));
}
