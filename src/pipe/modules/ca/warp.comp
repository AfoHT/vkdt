#version 460
#extension GL_GOOGLE_include_directive    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

// layout(std140, set = 0, binding = 1) uniform params_t
// { } params;

// layout(push_constant, std140) uniform push_t
// { uint filters; } push;

layout( // original input image
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // something desaturation for fringes
    set = 1, binding = 1
) uniform sampler2D img_desat;

layout( // coefficients
    set = 1, binding = 2
) uniform sampler2D img_coef;

layout( // corrected output
    set = 1, binding = 3
) uniform writeonly image2D img_out;

float
legendre_P(    // evaluate the legendre orthonormal basis
    int n,     // degree
    float x)   // |x|<1
{
  switch(n)
  { // not very elegant, could use some recursive definition instead
    case 0: return 1.0;
    case 1: return x;
    case 2: return 0.5   * (3.0*x*x - 1.0);
    case 3: return 0.5   * (5.0*x*x*x - 3.0*x);
    case 4: return 1.0/8.0  * (35.0*x*x*x*x - 30.0*x*x + 3.0);
    case 5: return 1.0/8.0  * (63*pow(x,5.0) - 70.0*x*x*x + 15.0*x);
    case 6: return 1.0/16.0 * (231.0*pow(x,6.0) - 315.0*x*x*x*x + 105*x*x - 5.0);
    default: return 0.0; // only up to degree 6
  }
}

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  const float px2ndc = 1.0/length(imageSize(img_out));
  vec2 c = 0.5*imageSize(img_out);
  vec2 r = ipos + 0.5 - c;
  float d0 = length(r) * px2ndc;
  vec2 c0 = vec2(texelFetch(img_coef, ivec2(0, 0), 0).r, texelFetch(img_coef, ivec2(0, 1), 0).r);
  vec2 c2 = vec2(texelFetch(img_coef, ivec2(1, 0), 0).r, texelFetch(img_coef, ivec2(1, 1), 0).r);
  vec2 c4 = vec2(texelFetch(img_coef, ivec2(2, 0), 0).r, texelFetch(img_coef, ivec2(2, 1), 0).r);
  vec2 c6 = vec2(texelFetch(img_coef, ivec2(3, 0), 0).r, texelFetch(img_coef, ivec2(3, 1), 0).r);
  vec2 cc = vec2(texelFetch(img_coef, ivec2(4, 0), 0).r, texelFetch(img_coef, ivec2(4, 1), 0).r);
#if 0 // plain:
  vec2 d1 = (c0 + c2 * legendre_P(2, d0)
                + c4 * legendre_P(4, d0)
                + c6 * legendre_P(6, d0)) / cc;
#else // force 0,0:
  vec2 d1 = (c2 * legendre_P(2, d0)
           + c4 * legendre_P(4, d0)
           + c6 * legendre_P(6, d0) - c2 * legendre_P(2, 0) - c4 * legendre_P(4, 0) - c6 * legendre_P(6, 0)) / cc;
#endif
  vec2 xr = ipos+0.5 - normalize(r) * d1.x/px2ndc;
  vec2 xb = ipos+0.5 - normalize(r) * d1.y/px2ndc;
  vec3 rgb;
  rgb.g = texture(img_in, (ipos+0.5)/imageSize(img_out)).g;
  rgb.r = texture(img_in, xr/imageSize(img_out)).r;
  rgb.b = texture(img_in, xb/imageSize(img_out)).b;
  float desat = texture(img_desat, (ipos+0.5)/imageSize(img_out)).r;
  // TODO: use img_desat to desaturate/equalise red/blue to green
  // imageStore(img_out, ipos, vec4(desat)+vec4(rgb,1));
  imageStore(img_out, ipos, vec4(rgb, 1));
  // imageStore(img_out, ipos, vec4(rgb.g, d1, 1.0));
  // imageStore(img_out, ipos, vec4(rgb.g));
  // imageStore(img_out, ipos, vec4(rgb, 1));
  // imageStore(img_out, ipos, vec4(d1, 1, 1));
}
