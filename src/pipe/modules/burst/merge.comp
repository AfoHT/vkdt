#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint scale;
  uint it;
} push;

layout( // distance buffers
    set = 1, binding = 0
) uniform sampler2D img_dist[25];

layout( // coarse offset buffer
    set = 1, binding = 1
) uniform sampler2D img_coff;

layout( // merged offset buffer
    set = 1, binding = 2
) uniform writeonly image2D img_out;

layout( // residual distance
    set = 1, binding = 3
) uniform writeonly image2D img_resid;

// merge offset buffers: pick one with smaller distance
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  // merge all offsets to find minimum distance
  // only one special case: do we have coarse or not (detect using scale):
  vec2 coff = vec2(0);
  if(push.scale > 0)
    coff = sample_soft(img_coff, (ipos+.5f)/vec2(push.scale*textureSize(img_coff, 0))).rg * push.scale;
  vec4 res1 = vec4(0, 0, 6500000, 1);
  vec4 res2 = vec4(0, 0, 6500000, 1);

  for(int idx=0;idx<25;idx++)
  {
    int offy = idx / 5;
    int offx = idx - offy * 5;
    offx -= 2; offy -= 2;
    // distance comes from a blurd output and we need to upsample it:
    float dist = sample_soft(img_dist[idx], (ipos+.5f)/vec2(imageSize(img_out))).r;
    // float dist = textureLod(img_dist[idx], (ipos+.5f)/vec2(imageSize(img_out)), 0).r;
    vec2 off = coff + ivec2(offx, offy);
#if 0
    // it == 0 is finest, it == 3 is coarsest
    if(push.it == 1)
      off = ivec2(offx, offy); // XXX
    else
      off = coff;// + ivec2(offx, offy); // XXX
#endif
    if(dist < res1.z)
    {
      res2 = res1;
      res1 = vec4(off, dist, 1);
    }
    else if(dist < res2.z)
    {
      res2 = vec4(off, dist, 1);
    }
  }
  // XXX FIXME: this doesn't work very well. use the sub-pixel smoothing from the paper instead!
  if(push.it == 0)
    res1 = (res1 / res1.z + res2 / res2.z) / (1./res1.z + 1./res2.z);

  imageStore(img_out, ipos, res1);
  // res.z *= 0.2;
  // float len = length(res.xy);
  // if(res.z < 0.13) res.z = 0;
  // if(res.z > 0.13) res.z = 0;
  // if(len > 10.00) res.z = 0;
  // TODO: parameter?
  // res.z = clamp(100*res.z, 0.0, 1.0); // mtest
  res1.z = clamp(10*res1.z, 0.0, 1.0); // himalaya
  // res.z = clamp(50*res.z-0.2, 0.0, 1.0);  // spheres
  // res.z = 0;
  // res.z = clamp(5*res.z, 0.0, 1.0);  // anti aliasing on ocean
  // res.z = pow(res.z, 5)+0.01;
  // res.z *= len;
  // res.z += 0.01*len;
  imageStore(img_resid, ipos, vec4(res1.z));
}

