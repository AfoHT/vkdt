#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 0) uniform params_t
{
  roi_t ri_dist;
  roi_t ri_coff;
  roi_t ri_loff;
  roi_t ro;
} params;

layout(push_constant, std140) uniform push_t
{
  ivec2 off;
  uint first_time;
  uint scale;
} push;

layout( // distance buffer
    set = 1, binding = 0
) uniform sampler2D img_dist;

layout( // coarse offset buffer
    set = 1, binding = 1
) uniform sampler2D img_coff;

layout( // offset buffer 1
    set = 1, binding = 2
) uniform sampler2D img_loff;

layout( // merged offset buffer
    set = 1, binding = 3
) uniform writeonly image2D img_out;

// merge offset buffers: pick one with smaller distance
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

#if 0
  // XXX DEBUG:
  vec2 debug = 2.0*vec2(ipos - params.ro.roi*0.5)/vec2(params.ro.roi);
  debug *= debug*debug;
  debug *= 50;
  imageStore(img_out, ipos, vec4(debug, 1, 1));
  return;
#endif

  // special cases:
  // * we are the first in our offset list, so there is nothing to merge but
  //   align the two buffers off + dist
  // * we are in the first cascade, so there is no coarse offset buffer img_off

  if(push.first_time == 0)
  { // regular case
    float dist = texelFetch(img_dist, ipos, 0).r;
    vec2  off  = textureLod(img_coff, ipos/vec2(push.scale*params.ri_coff.roi), 0).rg * push.scale + push.off;
    vec4 img1  = texelFetch(img_loff, ipos, 0);
    vec4 res = dist > img1.b ? img1 : vec4(off, dist, 1);
    imageStore(img_out, ipos, res);
  }
  else if(push.first_time == 1)
  { // first in the list, just align
    float dist = texelFetch(img_dist, ipos, 0).r;
    vec2  off  = textureLod(img_coff, ipos/vec2(push.scale*params.ri_coff.roi), 0).rg * push.scale + push.off;
    imageStore(img_out, ipos, vec4(off, dist, 1));
  }
  else if(push.first_time == 2)
  { // first level, merge but ignore coarse offset buffer
    float dist = texelFetch(img_dist, ipos, 0).r;
    ivec2 off  = push.off;
    vec4 img1  = texelFetch(img_loff, ipos, 0);
    vec4 res = dist > img1.b ? img1 : vec4(off, dist, 1);
    imageStore(img_out, ipos, res);
  }
  else
  { // first level and first in the list
    float dist = texelFetch(img_dist, ipos, 0).r;
    vec2  off  = push.off;
    imageStore(img_out, ipos, vec4(off, dist, 1));
  }
}

