#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(push_constant, std140) uniform push_t
{
  uint scale;
} push;

layout( // distance buffers
    set = 1, binding = 0
) uniform sampler2D img_dist[25];

layout( // coarse offset buffer
    set = 1, binding = 1
) uniform sampler2D img_coff;

layout( // merged offset buffer
    set = 1, binding = 2
) uniform writeonly image2D img_out;

// merge offset buffers: pick one with smaller distance
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  // merge all offsets to find minimum distance
  // only one special case: do we have coarse or not (detect using scale):
  vec2 coff = vec2(0);
  if(push.scale > 0)
    coff = sample_soft(img_coff, (ipos+.5f)/vec2(push.scale*textureSize(img_coff, 0))).rg * push.scale;
  vec4 res = vec4(0, 0, 6500000, 1);

  for(int idx=0;idx<25;idx++)
  {
    int offy = idx / 5;
    int offx = idx - offy * 5;
    offx -= 2; offy -= 2;
    // distance comes from a blurd output and we need to upsample it:
    float dist = sample_soft(img_dist[idx], (ipos+.5f)/vec2(imageSize(img_out))).r;
    vec2 off = coff + ivec2(offx, offy);
    if(dist < res.z)
      res = vec4(off, dist, 1);
  }
  imageStore(img_out, ipos, res);
}

