#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// global uniform stuff about image and roi
layout(std140, set = 0, binding = 0) uniform params_t
{
  roi_t ri_dist;
  roi_t ri_coff;
  roi_t ro;
} params;

layout(push_constant, std140) uniform push_t
{
  uint scale;
} push;

layout( // distance buffers
    set = 1, binding = 0
) uniform sampler2D img_dist[25];

layout( // coarse offset buffer
    set = 1, binding = 1
) uniform sampler2D img_coff;

layout( // merged offset buffer
    set = 1, binding = 2
) uniform writeonly image2D img_out;

// merge offset buffers: pick one with smaller distance
void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
  if(any(greaterThanEqual(ipos, params.ro.roi))) return;

  // merge all offsets to find minimum distance
  // float dist = texelFetch(img_dist[0], ipos, 0).r;
  // only one special case: do we have coarse or not (detect using scale):
  vec2 coff = vec2(0);
  if(push.scale > 0)
    coff = sample_catmull_rom(img_coff, ipos/vec2(push.scale*params.ri_coff.roi)).rg * push.scale;
  vec4 res = vec4(0, 0, 6500000, 1);

  for(int idx=0;idx<25;idx++)
  {
    int offy = idx / 5;
    int offx = idx - offy * 5;
    offx -= 2; offy -= 2;
    float dist = texelFetch(img_dist[nonuniformEXT(idx)], ipos, 0).r;
    vec2 off = coff + ivec2(offx, offy);
    if(dist < res.z)
      res = vec4(off, dist, 1);
  }
  imageStore(img_out, ipos, res);
}

